<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk F#: proměnné, funkce a datové typy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk F#: proměnné, funkce a datové typy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V úvodním článku o programovacím jazyku F# jsme si řekli, že základními stavebními kameny tohoto jazyka jsou neměnitelné hodnoty, funkce a datové typy. Dnes se na tyto koncepty podíváme podrobněji.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tisk hodnot na terminál mimo smyčku REPL</a></p>
<p><a href="#k02">2. Přiřazení hodnot k&nbsp;symbolům</a></p>
<p><a href="#k03">3. Rozdílné chování interpretru <strong>fsi</strong></a></p>
<p><a href="#k04">4. Neměnitelné hodnoty v&nbsp;jazyku F#</a></p>
<p><a href="#k05">5. Syntaxe pro modifikaci proměnné</a></p>
<p><a href="#k06">6. Měnitelné hodnoty aneb vstup do prvního stupně programátorského pekla</a></p>
<p><a href="#k07">7. Reference</a></p>
<p><a href="#k08">8. Použití referencí &ndash; jednoduchý čítač</a></p>
<p><a href="#k09">9. Alternativní syntaxe zápisu operací s&nbsp;referencemi</a></p>
<p><a href="#k10">10. Malá odbočka &ndash; standardní funkce <strong>incr</strong></a></p>
<p><a href="#k11">11. Základní datové typy v&nbsp;jazyku F#</a></p>
<p><a href="#k12">12. Typ <strong>unit</strong></a></p>
<p><a href="#k13">13. Typová inference a konstanty</a></p>
<p><a href="#k14">14. Polymorfické funkce</a></p>
<p><a href="#k15">15. n-tice</a></p>
<p><a href="#k16">16. Záznamy</a></p>
<p><a href="#k17">17. Typová inference u záznamů</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tisk hodnot na terminál mimo smyčku REPL</h2>

<p>V&nbsp;programovacím jazyku F# můžeme využít interaktivní smyčku REPL pro
postupné vyhodnocování jednotlivých výrazů. Výsledky těchto výrazů, což je vždy
jak hodnota, tak i typ, jsou ihned vypisovány na terminál. Ovšem
v&nbsp;reálných aplikacích nebo při spouštění skriptů přes <strong>dotnet
fsi</strong> se výsledky jednotlivých výrazů pochopitelně nevypisují. Jak je
tedy možné i v&nbsp;aplikacích popř.&nbsp;ve skriptech vypsat nějakou hodnotu
na obrazovku resp.&nbsp;na terminál? K&nbsp;tomuto účelu můžeme použít
standardní funkci nazvanou <strong>printf</strong>, která se, jak ostatně
uvidíme dále, používá podobně jako stejně pojmenovaná funkce v&nbsp;céčku či
dalších jazycích.</p>

<p>Prvním parametrem této funkce je formátovací řetězec, který může, ale také
nemusí obsahovat specifikaci formátování, řídicí znaky atd. Samozřejmě
v&nbsp;případě, že tento řetězec žádné speciální znaky neobsahuje, vypsat
zprávu na terminál přímo následujícím způsobem:</p>

<pre>
printf "www.root.cz"
</pre>

<p>To ve skutečnosti není ideální řešení; lepší je řetězec předat jako další
parametr:</p>

<pre>
printf "%s" "www.root.cz"
</pre>

<p>Překladač i interpret provádí kontrolu formátovacího řetězce a typu dalších
parametrů:</p>

<pre>
printf "%d" "Hello world"
</pre>

<p>Tento program je označen jako chybný:</p>

<pre>
The type 'string' is not compatible with any of the types
byte,int16,int32,int64,sbyte,uint16,uint32,uint64,nativeint,unativeint, arising
from the use of a printf-style format string
</pre>

<p>Prvním parametrem funkce <strong>printf</strong> musí být formátovací
řetězec, což je opět kontrolováno:</p>

<pre>
printf 42
</pre>

<p>I tento program je označen jako chybný:</p>

<pre>
The type 'int' is not compatible with the type 'Printf.TextWriterFormat&lt;'a&gt;'
</pre>

<p>Naopak tento program je plně funkční:</p>

<pre>
printf "answer is %d" 42
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Přiřazení hodnot k&nbsp;symbolům</h2>

<p>V&nbsp;programovacím jazyku F# se setkáme s&nbsp;konceptem, který se do
jisté míry podobá konceptu <i>proměnných</i> v&nbsp;dalších programovacích
jazycích. S&nbsp;využitím klíčového slova <strong>let</strong> je možné
vytvořit takzvanou vazbu (neboli <i>binding</i>) mezi novým symbolem (jménem) a
nějakou hodnotou, která je obecně výsledkem nějakého výrazu (i konstanta je
výrazem). V&nbsp;tom nejjednodušším případě může definice takové vazby vypadat
následovně:</p>

<pre>
let x = 42
</pre>

<p>S&nbsp;nově vzniklým symbolem můžeme provádět výpočty nebo s&nbsp;ním
manipulovat tak, jako přímo s&nbsp;hodnotou:</p>

<pre>
let x = 42
printf "x=%d" x
</pre>

<p>Možné je pochopitelně i provedení jednoduchého výpočtu s&nbsp;dosazením
výsledku do nového symbolu:</p>

<pre>
let x = 42
printf "x=%d" x
&nbsp;
let y = x + 1
printf "y=%d" y
</pre>

<p>Jednou definovaný symbol ovšem nelze <i>v&nbsp;daném bloku</i> (viz dále)
redefinovat, takže následující řádky nejsou korektní a překladač nás na tento
problém upozorní:</p>

<pre>
let x = 42
printf "x=%d" x
&nbsp;
let x = 6502
printf "x=%d" x
</pre>

<p>Chyba je v&nbsp;tomto případě detekována na čtvrtém řádku:</p>

<pre>
Duplicate definition of value 'x'
</pre>

<p>To ovšem znamená, že ani následující zápis není korektní:</p>

<pre>
let x = 42
printf "x=%d" x
&nbsp;
let y = x + 1
printf "y=%d" y
&nbsp;
let x = y + 1
printf "x=%d" x
</pre>

<p>Chybová zpráva je v&nbsp;tomto případě detekována na sedmém řádku:</p>

<pre>
Duplicate definition of value 'x'
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;výše uvedeného plyne, že
<strong>let</strong> slouží k&nbsp;definici symbolu, nikoli však
k&nbsp;přiřazení nové hodnoty k&nbsp;symbolu.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozdílné chování interpretru <strong>fsi</strong></h2>

<p>V&nbsp;případě, že předchozí programové řádky (a v&nbsp;tomto případě klidně
i bez řádků s&nbsp;<strong>printf</strong>) přepíšete do interaktivního REPLu
jazyka F# (<strong>dotnet fsi</strong>, lze ho však spustit i na
<strong>repl.it</strong>, jak již víme z&nbsp;úvodního článku), bude chování
kupodivu velmi odlišné, protože se bude zdát, že s&nbsp;pomocí
<strong>let</strong> skutečně můžeme proměnné redefinovat a tím pádem jim
přiřazovat nové hodnoty:</p>

<pre>
&gt; <strong>let x = 42;;</strong>
val x: int = 42
&nbsp;
&gt; <strong>let y = x + 1;;</strong>
val y: int = 43
&nbsp;
&gt; <strong>let x = x + 1;;</strong>
val x: int = 43
</pre>

<p>Ve skutečnosti se zde ovšem jedná o odlišný koncept &ndash; takzvaný
<i>shadowing</i>. Nově definovaný symbol (v&nbsp;tomto případě symbol
<strong>x</strong>) &bdquo;zastíní&ldquo; předchozí symbol. Ten sice stále
existuje, ale je v&nbsp;daném kontextu nedostupný.</p>

<p>Sice poněkud předbíháme, ale shadowing se projeví například i uvnitř funkce:</p>

<pre>
let shadow =
   let a = 1
   let a = 2
   a
&nbsp;
printf "%d" shadow
</pre>

<p>Tento program vypíše hodnotu 2.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;OCamlu, jak ostatně uvidíme
v&nbsp;dalším článku, k&nbsp;tomuto problému nedochází, neboť tento jazyk
vyžaduje použití klíčového slova <strong>in</strong>, které celý koncept
osvětluje.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Neměnitelné hodnoty v&nbsp;jazyku F#</h2>

<p>Až do této chvíle by se mohlo zdát, že se v&nbsp;případě příkazu
<strong>let</strong> vlastně jedná o klasickou deklaraci proměnné, což je i
důvod, proč se i v&nbsp;programovacím jazyku F# mluví o proměnných. Co ovšem
může být zpočátku matoucí, je fakt, že takto definované proměnné nejsou ve
skutečnosti měnitelné (<i>mutable</i>), takže samotný termín
&bdquo;proměnná&ldquo; (<i>variable</i>) může vést k&nbsp;nesprávným závěrům.
Ostatně pokusme se pro zajímavost změnit hodnotu proměnné <strong>x</strong>.
První úkol bude zjistit, jak se vlastně tato operace (modifikace hodnoty
proměnné) provádí. První pokus může vypadat takto:</p>

<pre>
let x = 42
printf "x=%d" x
&nbsp;
<strong>x = x + 1</strong>
printf "x=%d" x
</pre>

<p>Tento příklad je po syntaktické stránce (do určité míry!) korektní, ovšem
jak je tomu z&nbsp;pohledu sémantiky? Po spuštění tohoto prográmku se
vypíše:</p>

<pre>
x=42
x=42
</pre>

<p>Navíc překladač u tohoto příkladu vypíše varování:</p>

<pre>
The result of this equality expression has type 'bool' and is implicitly
discarded. Consider using 'let' to bind the result to a name, e.g. 'let result
= expression'. If you intended to mutate a value, then mark the value 'mutable'
and use the '&lt;-' operator e.g. 'x &lt;- expression'.
</pre>

<p>Důvod pro toto varování je jednoduchý &ndash; zápis <strong>x = x +
1</strong> totiž ve skutečnosti neznamená přiřazení nové hodnoty do proměnné
<strong>x</strong>, ale jedná se o porovnání, zda <strong>x</strong> je rovno
<strong>x+1</strong> (což evidentně nemůže nastat) a výsledná hodnota typu
<strong>bool</strong> (zde konkrétně <strong>false</strong>) je zahozena.
Ostatně funkci operátoru <strong>=</strong> si lze velmi snadno ověřit na tomto
demonstračním příkladu (operátor = je zvýrazněn i se svými operandy):</p>

<pre>
let x = 42
printf "x=%d" x
&nbsp;
printf "x=x+1? %b" (<strong>x=x+1</strong>)
printf "x=42?  %b" (<strong>x=42</strong>)
</pre>

<p>Výsledky budou vypadat následovně:</p>

<pre>
x=42
x=x+1? false
x=42?  true
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Syntaxe pro modifikaci proměnné</h2>

<p>Pro modifikaci proměnné je v&nbsp;programovacím jazyku F# zvolen poměrně
dobře čitelný zápis (který ale pravděpodobně bude mást programátory v&nbsp;Go,
kde znamená něco zcela odlišného):</p>

<pre>
existující_proměnná &lt;- nová hodnota
</pre>

<p>V&nbsp;předchozím textu jsme si řekli, že proměnné jsou ve výchozím stavu
neměnitelné, takže si vyzkoušejme, zda je tomu skutečně tak.
V&nbsp;následujícím programu nejdříve deklarujeme a inicializujeme novou
proměnnou <strong>x</strong>, poté se ji pokusíme modifikovat:</p>

<pre>
let x = 42
printf "x=%d" x
&nbsp;
x &lt;- x + 1
printf "x=%d" x
</pre>

<p>Překladač nás v&nbsp;tomto případě správně upozorní na to, že se snažíme
měnit neměnitelnou proměnnou. A dokonce nám ihned nabídne řešení, ke kterému se
vrátíme v&nbsp;navazující kapitole:</p>

<pre>
This value is not mutable. Consider using the mutable keyword, e.g. 'let mutable x = expression'.
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Měnitelné hodnoty aneb vstup do prvního stupně programátorského pekla</h2>

<p>U předchozího demonstračního příkladu nám překladač nabídl jedno
z&nbsp;možných řešení použitelných ve chvíli, kdy skutečně potřebujeme pracovat
s&nbsp;modifikovatelnými proměnnými. Proměnnou musíme jako měnitelnou označit
při její deklaraci klíčovým slovem <strong>mutable</strong>. Po takové úpravě
již bude možné hodnotu proměnné měnit tak, jak to známe z&nbsp;klasických
imperativních programovacích jazyků (zde konkrétně s&nbsp;využitím &lt;-):</p>

<pre>
let <strong>mutable</strong> x = 42
printf "x=%d" x
&nbsp;
x &lt;- x + 1
printf "x=%d" x
</pre>

<p>Výsledky získané po spuštění tohoto demonstračního příkladu ukazují, že
proměnná je skutečně měnitelná (a jedná se tedy o proměnnou v&nbsp;původním
slova smyslu tohoto termínu):</p>

<pre>
x=42
x=43
</pre>

<p><div class="rs-tip-major">Poznámka: zápis s&nbsp;<strong>mutable</strong> je
zdlouhavý a je to tak vlastně dobře, protože použití měnitelných proměnných by
mělo být spíše výjimečnou záležitostí (alespoň tak by tomu mělo být
v&nbsp;&bdquo;ideálním&ldquo; FP světě). Podobným směrem ostatně šel i jazyk
Rust, kde se používá kratší modifikátor <strong>mut</strong>, takže vývojář
není za použití měnitelné proměnné tak &bdquo;trestán&ldquo; jako v&nbsp;jazyku
F#.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Reference</h2>

<p>Kromě explicitně měnitelných proměnných můžeme v&nbsp;jazyku F# používat i
takzvané <i>reference</i>, což je koncept převzatý z&nbsp;jazyka <i>OCaml</i>
(a dále upravený). Referenci si můžeme představit jako proměnnou obsahující
adresu hodnoty uložené v&nbsp;operační paměti. Ovšem na rozdíl od céčka
s&nbsp;jeho konceptem ukazatelů jsou ve skutečnosti reference
v&nbsp;programovacím jazyku F# plně typované.</p>

<p>Proměnná obsahující referenci je deklarována s&nbsp;využitím modifikátoru
<strong>ref</strong>:</p>

<pre>
let x = ref 42
</pre>

<p>Modifikace referencované hodnoty se provádí s&nbsp;využitím operátoru :=
(tedy nikoli šipky, jako je tomu u měnitelné proměnné):</p>

<pre>
x := 0
</pre>

<p>A pro získání hodnoty se používá operátor !, což je ukázáno na dalším
řádku:</p>

<pre>
Printf.printf "x=%d\n" !x
</pre>

<p><div class="rs-tip-major">Poznámka: tyto zápisy jsou převzaty z&nbsp;OCamlu.
V&nbsp;jazyku F# je navíc nabízen i alternativní zápis (který vypadá více
&bdquo;objektově&ldquo;). Ten si ukážeme v&nbsp;dalším textu.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití referencí &ndash; jednoduchý čítač</h2>

<p>Podívejme se nyní na jednoduchý &bdquo;školní&ldquo; příklad, v&nbsp;němž je
využita reference pro realizaci jednoduchého čítače. Bude se tedy jednat o
proměnnou, jejíž hodnotu lze zvýšit o jedničku popř.&nbsp;danou hodnotu
přečíst. Víme již, že proměnnou s&nbsp;referencí musíme deklarovat
s&nbsp;využitím modifikátoru <strong>ref</strong>, změnu reference zařizuje
operátor := a přečtení referencované hodnoty operátor !. Zbytek je již
jednoduchý:</p>

<pre>
let x = ref 42
Printf.printf "x=%d\n" !x
&nbsp;
x := !x + 1
Printf.printf "x=%d\n" !x
</pre>

<p>Tento prográmek po svém spuštění vypíše:</p>

<pre>
x=42
x=43
</pre>

<p><div class="rs-tip-major">Poznámka: reference ovšem mají i mnohem
užitečnější způsoby využití, což je opět téma, kterému se ještě budeme
věnovat.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Alternativní syntaxe zápisu operací s&nbsp;referencemi</h2>

<p>Přístup k&nbsp;referencované hodnotě přes operátor ! a modifikace reference
operátorem := je ve skutečnosti syntaxe, která byla převzata z&nbsp;jazyka
OCaml. V&nbsp;F# je nabízena ještě jedna alternativní syntaxe, která
s&nbsp;referencí pracuje tak, jakoby se jednalo o datovou strukturu
s&nbsp;jediným měnitelným prvkem nazvaným <strong>Value</strong>. To tedy
znamená, že namísto zápisu:</p>

<pre>
!reference
</pre>

<p>můžeme psát:</p>

<pre>
reference.Value
</pre>

<p>Navíc operace přiřazení nové hodnoty se namísto:</p>

<pre>
reference := výraz
</pre>

<p>může zapsat stylem:</p>

<pre>
reference.Value &lt;- výraz
</pre>

<p>Náš příklad s&nbsp;čítačem je tedy možné přepsat do této podoby:</p>

<pre>
let x = ref 42
Printf.printf "x=%d\n" x.Value
&nbsp;
x.Value &lt;- x.Value + 1
Printf.printf "x=%d\n" x.Value
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Malá odbočka &ndash; standardní funkce <strong>incr</strong></h2>

<p>V&nbsp;jazyku OCaml existuje standardní funkce nazvaná
<strong>incr</strong>, která dokáže zvýšit referencovanou celočíselnou hodnotu
o jedničku (a současně nevrací žádnou hodnotu, k&nbsp;čemuž se záhy dostaneme).
Typ této funkce tedy je:</p>

<pre>
val incr : int ref -&gt; unit
</pre>

<p>Programovací jazyk F# tuto funkci převzal do své standardní knihovny, takže
ji můžeme použít i zde. Oba příklady z&nbsp;předchozích dvou kapitol je tedy
možné přepsat následujícím způsobem:</p>

<pre>
let x = ref 42
printf "x=%d\n" x.Value
&nbsp;
<strong>incr x</strong>
printf "x=%d\n" x.Value
</pre>

<p>Výsledkem bude podle očekávání:</p>

<pre>
x=42
x=43
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak je tento kód
nefunkcionální, a to dokonce na několika místech. Používáme zde měnitelné
hodnoty (dostupné přes reference) a funkci s&nbsp;vedlejším efektem.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní datové typy v&nbsp;jazyku F#</h2>

<p>V&nbsp;navazujících kapitolách se seznámíme s&nbsp;některými koncepty, na
nichž je postaven typový systém programovacího jazyka F#. Nejprve si však pro
úplnost vyjmenujme základní datové typy, které tento programovací jazyk nabízí.
Vzhledem k&nbsp;tomu, že F# je primárně provozován v&nbsp;ekosystému .NET, je u
každého typu ještě uveden odpovídající typ v&nbsp;.NET:</p>

<table>
<tr><th>Typ</th><th>v .NET</th><th>stručný popis</th></tr>
<tr><td>bool</td><td>Boolean</td><td>pravdivostní hodnoty <strong>true</strong> a <strong>false</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>byte</td><td>Byte</td><td>celočíselné hodnoty v&nbsp;rozsahu 0 to 255</td></tr>
<tr><td>sbyte</td><td>SByte</td><td>celočíselné hodnoty v&nbsp;rozsahu -128 to 127</td></tr>
<tr><td>int16</td><td>Int16</td><td>celočíselné hodnoty v&nbsp;rozsahu -32768 to 32767</td></tr>
<tr><td>uint16</td><td>UInt16</td><td>celočíselné hodnoty v&nbsp;rozsahu 0 to 65535</td></tr>
<tr><td>int</td><td>Int32</td><td>celočíselné hodnoty v&nbsp;rozsahu -2 147 483 648 to 2 147 483 647</td></tr>
<tr><td>uint</td><td>UInt32</td><td>celočíselné hodnoty v&nbsp;rozsahu 0 to 4 294 967 295</td></tr>
<tr><td>int64</td><td>Int64</td><td>celočíselné hodnoty v&nbsp;rozsahu -9 223 372 036 854 775 808 to 9 223 372 036 854 775 807</td></tr>
<tr><td>uint64</td><td>UInt64</td><td>celočíselné hodnoty v&nbsp;rozsahu 0 to 18 446 744 073 709 551 615</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>nativeint</td><td>IntPtr</td><td>ukazatel na celočíselnou hodnotu se znaménkem</td></tr>
<tr><td>unativeint</td><td>UIntPtr</td><td>ukazatel na celočíselnou hodnotu bez znaménka</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>decimal</td><td>Decimal</td><td>hodnota s&nbsp;plovoucí řádovou čárkou</td></tr>
<tr><td>float, double</td><td>Double</td><td>hodnota s&nbsp;plovoucí řádovou čárkou dle IEEE 754 double precision</td></tr>
<tr><td>float32, single</td><td>Single </td><td>hodnota s&nbsp;plovoucí řádovou čárkou dle IEEE 754 single precision</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>char</td><td>Char</td><td>znak v&nbsp;Unicode</td></tr>
<tr><td>string</td><td>String</td><td>řetězec Unicode znaků</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že zejména u typu
<strong>float</strong> může lehce dojít ke zmatkům.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Typ <strong>unit</strong></h2>

<p>Ve skutečnosti se ještě setkáme (a vlastně už i setkali v&nbsp;případě
funkce <strong>incr</strong> s&nbsp;dalším datovým typem, který se nazývá
<strong>unit</strong> (viz též <a
href="https://en.wikipedia.org/wiki/Unit_type">toto heslo</a>). Tento datový
typ má jedinou (formální) hodnotu zapisovanou s&nbsp;využitím prázdných
kulatých závorek, tedy takto: (). V&nbsp;jazyku F# se tato hodnota používá
v&nbsp;těch místech, kde je formálně nutné zapsat nějaký typ či hodnotu, ale
žádný takový typ ani hodnota nedává smysl. Příkladem je opět funkce
<strong>incr</strong>, která provádí nějakou činnost (zvyšuje hodnotu
referencované proměnné), ovšem nic nevrací. A právě návratovým typem takové
funkce je <strong>()</strong>. Tento typ se ovšem odlišuje od
<strong>void</strong> z&nbsp;céčka, k&nbsp;čemuž se ještě vrátíme (ve
stručnosti &ndash; <strong>void</strong> není plnohodnotným typem).</p>

<p><div class="rs-tip-major">Poznámka: tím, že má typ <strong>unit</strong>
jedinou hodnotu vlastně říkáme, že tato hodnota nenese žádnou informaci (když
je pravděpodobnost, že z&nbsp;komunikačního kanálu získám ve 100% stejný
symbol, jeho informační hodnota je 0 bitů).</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Typová inference a konstanty</h2>

<p>Vzhledem k&nbsp;tomu, jakým způsobem je realizována typová inference
v&nbsp;jazyku F#, je v&nbsp;naprosté většině případů možné vynechat specifikaci
datových typů. Ovšem jakým způsobem se například rozliší mezi hodnotou typu
<strong>byte</strong> a hodnotou typu <strong>int</strong>, když se například
bude jednat o nulovou hodnotu? Řešení, které F# nabízí, spočívá v&nbsp;použití
suffixů u zapisovaných konstant:</p>

<table>
<tr><th>Typ</th><th>Suffix (příklad)</th></tr>
<tr><td>byte</td><td>1uy</td></tr>
<tr><td>sbyte</td><td>1y</td></tr>
<tr><td>int16</td><td>1s</td></tr>
<tr><td>uint16</td><td>1us</td></tr>
<tr><td>int</td><td>1</td></tr>
<tr><td>uint</td><td>1u</td></tr>
<tr><td>int64</td><td>1L</td></tr>
<tr><td>uint64</td><td>1UL</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>decimal</td><td>1.0m</td></tr>
<tr><td>float, double</td><td>1.0</td></tr>
<tr><td>float32, single</td><td>1.0f</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>char</td><td>'*'</td></tr>
<tr><td>string</td><td>"www.root.cz"</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Polymorfické funkce</h2>

<p>Podívejme se nyní na zajímavý problém. Nadeklarujeme funkci (pro
jednoduchost pojmenovanou <strong>ident</strong>), která akceptuje nějaký
parametr pojmenovaný <strong>x</strong> a hodnotu tohoto parametru vrátí jako
svůj výsledek. U této funkce ovšem nikde nespecifikujeme ani typ parametru ani
typ návratové hodnoty:</p>

<pre>
let ident x = x;;
</pre>

<p>Nyní si asi položíte otázku, zda je vůbec možné takovou funkci v&nbsp;silně
typovaném jazyku, jakým F# bezesporu je, nadeklarovat. Překladač totiž nyní
nemá k&nbsp;dispozici žádné nápovědy k&nbsp;určení typu parametru či typu
návratové hodnoty (tak jako to měl v&nbsp;případě funkce s&nbsp;nějakým
&bdquo;typově jednoznačným&ldquo; výrazem).</p>

<p>Tato deklarace funkce ve skutečnosti je v&nbsp;Hindleyho-Milnerově typovém
systému řešitelná (řešení přidal právě Milner). Výsledkem bude funkce
akceptující i vracející obecný (dále nespecifikovaný) typ
<strong>a</strong>:</p>

<pre>
val ident : 'a -&gt; 'a = &lt;fun&gt;
</pre>

<p>Funkci nyní můžeme zavolat s&nbsp;parametry různých typů a výsledkem opět
budou hodnoty různých typů (viz znaky ve formátovacím řetězci):</p>

<pre>
Printf.printf "ident=%d\n" (ident 10);;
Printf.printf "ident=%s\n" (ident "foo");;
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé bude zjistit, jak tento
polymorfický typ &bdquo;probublává&ldquo; přes větší množství funkcí.
K&nbsp;tomuto konceptu se pochopitelně ještě dostaneme.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. n-tice</h2>

<p>V&nbsp;programovacím jazyku F# jsou podporovány tři základní složené datové
typy. Jedná se o n-tice, záznamy a seznamy. Nejjednodušší jsou n-tice, které
mohou obsahovat prvky libovolných typů. Typ n-tice jako celku je pak odvozen od
typů jednotlivých prvků. Speciálním případem je n-tice bez prvků, neboli datový
typ <strong>unit</strong> zmíněný výše.</p>

<p>Použití n-tice se dvěma prvky typu <strong>int</strong>:</p>

<pre>
<strong>Printf.printf "%A" (1,2)</strong>
</pre>

<p>Typ této n-tice se zapisuje takto:</p>

<pre>
int * int = (1, 2)
</pre>

<p>Typ složitější n-tice:</p>

<pre>
<strong>(1, 1.5, "foo", (1,2)) ;;</strong>
&nbsp;
- : int * float * string * (int * int) = (1, 1.5, "foo", (1, 2))
</pre>

<p>N-tici je samozřejmě možné přiřadit do proměnné a poté si nechat vytisknout
její obsah:</p>

<pre>
<strong>let x = (1,2,3)</strong>
<strong>Printf.printf "%A" x</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že n-tice
s&nbsp;jediným prvkem nemá praktický význam, není podporována (na rozdíl od
Pythonu, kde se však jedná o syntakticky problematický rys jazyka).</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Záznamy</h2>

<p>Následují záznamy (<i>records</i>), v&nbsp;nichž jsou uloženy prvky taktéž
libovolného typu, ovšem na rozdíl od n-tic jsou tyto prvky pojmenovány. Zde je
již nutné definovat nový datový typ s&nbsp;explicitním určením typů
jednotlivých položek (další možnosti si popíšeme jindy). Datový typ
<strong>car</strong> může být definován takto:</p>

<pre>
type car = {
    Color: string;
    Model: string;
    Manufacturer: string;
    Year: int;
}
</pre>

<p>Vytvoření proměnné s&nbsp;hodnotou tohoto typu se zapisuje následujícím stylem:</p>

<pre>
<strong>let toyota :car = {Color="silver"; Model="Corolla"; Manufacturer="Toyota"; Year=1986};;</strong>
&nbsp;
Printf.printf "%A" toyota
</pre>

<p><div class="rs-tip-major">Poznámka: pro novou proměnnou
<strong>toyota</strong> platí všechny vlastnosti proměnných zmíněné výše,
tj.&nbsp;neměnitelnost atd.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Typová inference u záznamů</h2>

<p>I u proměnných či parametrů typu záznam se uplatňuje typová inference, což
konkrétně znamená, že například v&nbsp;následujícím příkladu nemusíme u
proměnné <strong>toyota</strong> explicitně deklarovat její typ:</p>

<pre>
type car = {
    Color: string;
    Model: string;
    Manufacturer: string;
    Year: int;
}
&nbsp;
let toyota = {Color="silver"; Model="Corolla"; Manufacturer="Toyota"; Year=1986};;
&nbsp;
Printf.printf "%A" toyota
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/f-sharp-examples/">https://github.com/tisnik/f-sharp-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>ML/fib_recursive.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti rekurzivně</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_recursive.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_recursive.ml</a></td></tr>
<tr><td> 2</td><td>ML/fib_pattern_matching.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_pattern_matching.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_pattern_matching.ml</a></td></tr>
<tr><td> 3</td><td>ML/len_pattern_matching_1.ml</td><td>výpočet délky seznamu založený na pattern matchingu (první varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_1.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_1.ml</a></td></tr>
<tr><td> 4</td><td>ML/len_pattern_matching_2.ml</td><td>výpočet délky seznamu založený na pattern matchingu (zkrácená varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_2.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>OCaml/fib_recursive.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti rekurzivně</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_recursive.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_recursive.ml</a></td></tr>
<tr><td> 6</td><td>OCaml/fib_tail_recursive.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti s&nbsp;využitím koncové rekurze</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_tail_recursive.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_tail_recursive.ml</a></td></tr>
<tr><td> 7</td><td>OCaml/fib_pattern_matching.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_pattern_matching.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_pattern_matching.ml</a></td></tr>
<tr><td> 8</td><td>OCaml/local_binding.ml</td><td>symbol lokální uvnitř funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/local_binding.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/local_binding.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>article_01/function.fs</td><td>deklarace pojmenované funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function.fs</a></td></tr>
<tr><td>10</td><td>article_01/lambda.fs</td><td>deklarace anonymní funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/lambda.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/lambda.fs</a></td></tr>
<tr><td>11</td><td>article_01/local_binding_1.fs</td><td>lokální symboly ve funkci</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_1.fs</a></td></tr>
<tr><td>12</td><td>article_01/local_binding_2.fs</td><td>lokální symboly ve funkci</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_2.fs</a></td></tr>
<tr><td>13</td><td>article_01/function_type_1.fs</td><td>explicitní definice návratového typu funkce (korektní)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_1.fs</a></td></tr>
<tr><td>14</td><td>article_01/function_type_2.fs</td><td>explicitní definice návratového typu funkce (nekorektní)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>article_02/basic_binding.fs</td><td>navázání hodnoty na symbol (deklarace proměnné)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fs</a></td></tr>
<tr><td>16</td><td>article_02/print_variable.fs</td><td>tisk hodnoty proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fs</a></td></tr>
<tr><td>17</td><td>article_02/variables_and_functions.fs</td><td>předání proměnné do funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fs</a></td></tr>
<tr><td>18</td><td>article_02/redefine_symbol_1.fs</td><td>pokus o redefinici symbolu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fs</a></td></tr>
<tr><td>19</td><td>article_02/redefine_symbol_2.fs</td><td>pokus o redefinici symbolu (složitější příklad)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>article_02/equal_operator_1.fs</td><td>operátor =</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fs</a></td></tr>
<tr><td>21</td><td>article_02/equal_operator_2.fs</td><td>operátor =</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>article_02/immutable_variable.fs</td><td>&bdquo;změna&ldquo; neměnitelné proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fs</a></td></tr>
<tr><td>23</td><td>article_02/mutable_variable.fs</td><td>změna měnitelné proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fs</a></td></tr>
<tr><td>24</td><td>article_02/reference_1.fs</td><td>reference, příklad kompatibilní s&nbsp;OCamlem</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fs</a></td></tr>
<tr><td>25</td><td>article_02/reference_2.fs</td><td>reference, nová syntaxe pro F#</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fs</a></td></tr>
<tr><td>26</td><td>article_02/incr1.fs</td><td>standardní funkce <strong>incr</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fs</a></td></tr>
<tr><td>27</td><td>article_02/incr2.fs</td><td>zvýšení referencované hodnoty o jedničku</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fs</a></td></tr>
<tr><td>28</td><td>article_02/shadow.fs</td><td>shadowing symbolu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/shadow.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/shadow.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>article_02/tuple.fs</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/tuple.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/tuple.fs</a></td></tr>
<tr><td>30</td><td>article_02/record_1.fs</td><td>datový typ záznam (<i>record</i>), deklarace proměnné tohoto typu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_1.fs</a></td></tr>
<tr><td>31</td><td>article_02/record_2.fs</td><td>datový typ záznam (<i>record</i>) a typová inference při deklaraci proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>article_02/basic_binding.fsx</td><td>demonstrační příklad <strong>basic_binding.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fsx</a></td></tr>
<tr><td>33</td><td>article_02/equal_operator_1.fsx</td><td>demonstrační příklad <strong>equal_operator_1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fsx</a></td></tr>
<tr><td>34</td><td>article_02/equal_operator_2.fsx</td><td>demonstrační příklad <strong>equal_operator_2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fsx</a></td></tr>
<tr><td>35</td><td>article_02/immutable_variable.fsx</td><td>demonstrační příklad <strong>immutable_variable.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fsx</a></td></tr>
<tr><td>36</td><td>article_02/mutable_variable.fsx</td><td>demonstrační příklad <strong>mutable_variable.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fsx</a></td></tr>
<tr><td>37</td><td>article_02/print_variable.fsx</td><td>demonstrační příklad <strong>print_variable.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fsx</a></td></tr>
<tr><td>38</td><td>article_02/redefine_symbol_1.fsx</td><td>demonstrační příklad <strong>redefine_symbol_1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fsx</a></td></tr>
<tr><td>39</td><td>article_02/redefine_symbol_2.fsx</td><td>demonstrační příklad <strong>redefine_symbol_2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fsx</a></td></tr>
<tr><td>40</td><td>article_02/variables_and_functions.fsx</td><td>demonstrační příklad <strong>variables_and_functions.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fsx</a></td></tr>
<tr><td>41</td><td>article_02/incr1.fsx</td><td>demonstrační příklad <strong>incr1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fsx</a></td></tr>
<tr><td>42</td><td>article_02/incr2.fsx</td><td>demonstrační příklad <strong>incr2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fsx</a></td></tr>
<tr><td>43</td><td>article_02/reference_1.fsx</td><td>demonstrační příklad <strong>reference_1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fsx</a></td></tr>
<tr><td>44</td><td>article_02/reference_2.fsx</td><td>demonstrační příklad <strong>reference_2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fsx</a></td></tr>
<tr><td>45</td><td>article_02/ident.fsx</td><td>demonstrační příklad <strong>ident.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/ident.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/ident.fsx</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny knihy
o jazyku ML resp.&nbsp;Standard ML i knihy o programovacím jazyku OCaml, který
ze Standard ML ze značné míry vychází. A samozřejmě nezapomeneme ani na knihy o
jazyku F#:</div></p>

<ol>

<li>Get Programming with F#<br />
<a href="https://www.manning.com/books/get-programming-with-f-sharp">https://www.manning.com/books/get-programming-with-f-sharp</a>
</li>

<li>F# for Scientists<br />
<a href="https://www.amazon.com/F-Scientists-Jon-Harrop-ebook/dp/B005PS97RO">https://www.amazon.com/F-Scientists-Jon-Harrop-ebook/dp/B005PS97RO</a>
</li>

<li>Domain Modeling Made Functional<br />
<a href="https://fsharpforfunandprofit.com/books/">https://fsharpforfunandprofit.com/books/</a>
</li>

<li>Functional Programming with F# (na Overleaf, tedy i se zdrojovými kódy)<br />
<a href="https://www.overleaf.com/project/5bf2cb3cd9568d5a75bfcba9">https://www.overleaf.com/project/5bf2cb3cd9568d5a75bfcba9</a>
</li>

<li>Book of F#<br />
<a href="https://nostarch.com/fsharp">https://nostarch.com/fsharp</a>
</li>

<li>F# Programming (Wikibook)<br />
<a href="https://en.wikibooks.org/wiki/F_Sharp_Programming">https://en.wikibooks.org/wiki/F_Sharp_Programming</a>
</li>

<li>Stylish F#: Crafting Elegant Functional Code for .NET and .NET Core<br />
<a href="https://www.amazon.com/dp/1484239997/">https://www.amazon.com/dp/1484239997/</a>
</li>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>General-Purpose, Industrial-Strength, Expressive, and Safe<br />
<a href="https://ocaml.org/">https://ocaml.org/</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

<li>ForLoops<br />
<a href="http://mlton.org/ForLoops">http://mlton.org/ForLoops</a>
</li>

<li>Funkcionální dobrodružství v&nbsp;JavaScriptu<br />
<a href="https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html">https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html</a>
</li>

<li>Recenze knihy Functional Thinking (Paradigm over syntax)<br />
<a href="https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>.NET framework<br />
<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a>
</li>

<li>F# - .NET Blog<br />
<a href="https://devblogs.microsoft.com/dotnet/category/fsharp/">https://devblogs.microsoft.com/dotnet/category/fsharp/</a>
</li>

<li>Playground: OCaml<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>The F# Survival Guide<br />
<a href="https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx">https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Why Programmers Need Limits<br />
<a href="https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db">https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db</a>
</li>

<li>Signatures<br />
<a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files">https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files</a>
</li>

<li>F# for Linux People<br />
<a href="https://carpenoctem.dev/blog/fsharp-for-linux-people/">https://carpenoctem.dev/blog/fsharp-for-linux-people/</a>
</li>

<li>Ionide project<br />
<a href="https://ionide.io/">https://ionide.io/</a>
</li>

<li>FsAutoComplete<br />
<a href="https://ionide.io/Tools/fsac.html">https://ionide.io/Tools/fsac.html</a>
</li>

<li>Interactive (.NET for Jupyter Notebook)<br />
<a href="https://github.com/dotnet/interactive/#jupyter-and-nteract">https://github.com/dotnet/interactive/#jupyter-and-nteract</a>
</li>

<li>let Bindings<br />
<a href="https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/let-bindings.md">https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/let-bindings.md</a>
</li>

<li>Lambda Expressions: The fun Keyword (F#)<br />
<a href="https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/lambda-expressions-the-fun-keyword.md">https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/lambda-expressions-the-fun-keyword.md</a>
</li>

<li>Infographic showing code complexity vs developer experience<br />
<a href="https://twitter.com/rossipedia/status/1580639227313676288">https://twitter.com/rossipedia/status/1580639227313676288</a>
</li>

<li>OCaml for the Masses: Why the next language you learn should be functional<br />
<a href="https://queue.acm.org/detail.cfm?id=2038036">https://queue.acm.org/detail.cfm?id=2038036</a>
</li>

<li>Try EIO<br />
<a href="https://patricoferris.github.io/try-eio/">https://patricoferris.github.io/try-eio/</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>ML &ndash; funkcionální jazyk s revolučním typovým systémem<br />
<a href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/</a>
</li>

<li>Funkce a typový systém programovacího jazyka ML<br />
<a href="https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/">https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/</a>
</li>

<li>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML<br />
<a href="https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/">https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/</a>
</li>

<li>Operátor J (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/J_operator">https://en.wikipedia.org/wiki/J_operator</a>
</li>

<li>Standard ML (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Standard_ML">https://en.wikipedia.org/wiki/Standard_ML</a>
</li>

<li>Don Syme<br />
<a href="https://en.wikipedia.org/wiki/Don_Syme">https://en.wikipedia.org/wiki/Don_Syme</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Xavier Leroy<br />
<a href="https://en.wikipedia.org/wiki/Xavier_Leroy">https://en.wikipedia.org/wiki/Xavier_Leroy</a>
</li>

<li>Unit type<br />
<a href="https://en.wikipedia.org/wiki/Unit_type">https://en.wikipedia.org/wiki/Unit_type</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>
