<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Definice uživatelských datových typů v jazyku F#</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Definice uživatelských datových typů v jazyku F#</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Prozatím jsme si do značné míry vystačili se základními datovými typy jazyka F#. Ovšem velká síla tohoto jazyka spočívá v principu deklarace nových datových typů. Podporován je algebraický typový systém, ale například i možnost deklarace tříd s jejich hierarchií.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Definice uživatelských datových typů v&nbsp;jazyku F#</a></p>
<p><a href="#k02">2. Datový typ záznam (<i>record</i>)</a></p>
<p><a href="#k03">3. Typová inference při definici funkcí</a></p>
<p><a href="#k04">4. Chování algoritmu typové inference v&nbsp;případě dvou struktur se shodnými prvky</a></p>
<p><a href="#k05">5. Datový typ výčet (<i>enum</i>)</a></p>
<p><a href="#k06">6. Datový typ disjunktní sjednocení (<i>discriminated union</i>)</a></p>
<p><a href="#k07">7. N-tice</a></p>
<p><a href="#k08">8. N-tice a pattern matching</a></p>
<p><a href="#k09">9. Od n-tic k&nbsp;sofistikovanějším disjunktním sjednocením</a></p>
<p><a href="#k10">10. Disjunktní sjednocení s&nbsp;prvky typu n-tice</a></p>
<p><a href="#k11">11. Rekurzivní datové typy</a></p>
<p><a href="#k12">12. Datový typ třída (<i>class</i>)</a></p>
<p><a href="#k13">13. Lokální symbol v&nbsp;deklaraci třídy</a></p>
<p><a href="#k14">14. Konstrukce nové instance třídy realizovaná v&nbsp;metodě</a></p>
<p><a href="#k15">15. Operátory definované v&nbsp;rámci uživatelského datového typu</a></p>
<p><a href="#k16">16. Dědičnost</a></p>
<p><a href="#k17">17. Operátor <strong>upcast</strong>: přetypování na předka</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Definice uživatelských datových typů v&nbsp;jazyku F#</h2>

<p>Prozatím jsme si <a
href="https://www.root.cz/serialy/f-a-ocaml/">v&nbsp;seriálu o programovacích
jazycích OCaml a F#</a> do značné míry vystačili se základními datovými typy
programovacího jazyka F# (resp.&nbsp;OCamlu). Ovšem velká síla těchto dvou
programovacích jazyků spočívá v&nbsp;principu deklarace nových datových typů.
Podporován je takzvaný <i>algebraický typový systém</i> (který byl v&nbsp;OCaml
dále rozšířen), ale například i možnost deklarace tříd a specifikace jejich
hierarchie (i když v&nbsp;F# ani v&nbsp;OCamlu není tak velký
&bdquo;tlak&ldquo; na použití tříd, a to právě díky možnostem poskytovaných
ostatními datovými typy).</p>

<p>V&nbsp;mnoha demonstračních příkladech uvedených v&nbsp;navazujících
kapitolách se navíc setkáme s&nbsp;tím, že operace nad různými datovými typy
jsou prováděny s&nbsp;využitím <i>pattern matchingu</i>, přičemž stojí za
povšimnutí, že <i>konstrukce</i> hodnoty určitého datového typu vypadá po
syntaktické stránce prakticky stejně, jako <i>dekonstrukce</i> hodnoty na její
prvky v&nbsp;bloku <strong>match</strong>. To je poměrně typický rys pattern
matchingu, který byl do určité míry přejat i do dalších programovacích jazyků,
které dnes pattern matching podporují.</p>

<p><div class="rs-tip-major">Poznámka: opět platí, že všechny dále uvedené
demonstrační příklady je možné si vyzkoušet ve webové aplikaci <a
href="https://try.fsharp.org/">Try F#</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Datový typ záznam (<i>record</i>)</h2>

<p>V&nbsp;mnoha oblastech se používá datový typ záznam (<i>record</i>).
V&nbsp;záznamech mohou být uloženy prvky (resp.&nbsp;přesněji řečeno složky)
libovolného typu, ovšem na rozdíl od již popsaných n-tic (<i>tuple</i>) jsou
tyto prvky pojmenovány a lze k&nbsp;nim přistupovat s&nbsp;využitím známé
tečkové notace (tečka přitom není v&nbsp;tomto kontextu operátor, ale znak se
speciálním významem &ndash; <i>special symbol</i>). U záznamů je, na rozdíl od
n-tic, seznamů či polí, již nutné definovat nový datový typ s&nbsp;explicitním
určením typů jednotlivých položek.</p>

<p>Jak práce se seznamy vypadá v&nbsp;praxi? Datový typ <strong>User</strong>
se třemi složkami může být definován následujícím způsobem:</p>

<pre>
type <strong>User</strong> =
    { ID: int
      Name: string
      Surname: string}
</pre>

<p>Vytvoření proměnné s&nbsp;hodnotou tohoto typu se zapisuje stylem, který je
ukázán pod tímto odstavcem:</p>

<pre>
let <strong>pepa</strong> =
    { ID = 42
      Name = "Josef"
      Surname = "Vyskočil"}
&nbsp;
&nbsp;
printf "%A\n" pepa
</pre>

<p>Samozřejmě si můžeme v&nbsp;případě potřeby nadeklarovat i funkci (například
pojmenovanou <strong>print_name</strong>), která akceptuje parametr typu
záznam. V&nbsp;této funkci navíc budeme přistupovat ke složkám záznamu
s&nbsp;využitím dnes již téměř univerzální &bdquo;tečkové notace&ldquo;:</p>

<pre>
type <strong>User</strong> =
    { ID: int
      Name: string
      Surname: string}
&nbsp;
let <strong>print_name</strong> (x:User) =
    printf "%s %s" x.Name x.Surname
&nbsp;
let pepa =
    { ID = 42
      Name = "Josef"
      Surname = "Vyskočil"}
&nbsp;
&nbsp;
print_name pepa
</pre>

<p><div class="rs-tip-major">Poznámka: prakticky totožným způsobem bylo možné
se záznamy pracovat již v&nbsp;původním jazyku ML, od nějž je odvozen jak jazyk
OCaml, tak i programovací jazyk F#.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Typová inference při definici funkcí</h2>

<p>Již několikrát jsme se <a
href="https://www.root.cz/serialy/f-a-ocaml/">v&nbsp;tomto seriálu</a> setkali
s&nbsp;tím, že programovací jazyky OCaml a F# používají sofistikovaný
algoritmus pro typovou inferenci (<i>type inference</i>), který například
dokáže doplnit typ parametrů do definované funkce, a to na základě jejího těla.
Můžeme si tedy vyzkoušet upravit funkci <a href="#k02">z&nbsp;předchozí
kapitoly</a>. Původní tvar této funkce explicitně specifikoval typ
parametrů:</p>

<pre>
let <strong>print_name</strong> (x:User) =
    printf "%s %s" x.Name x.Surname
</pre>

<p>Ovšem v&nbsp;tomto případě (až na výjimky zmíněné níže) můžeme funkci napsat
jednodušeji a přitom bude stále silně typovaná:</p>

<pre>
let <strong>print_name</strong> x =
    printf "%s %s" x.Name x.Surname
</pre>

<p>Následující skript je korektní a plně funkční:</p>

<pre>
type <strong>User</strong> =
    { ID: int
      Name: string
      Surname: string}
&nbsp;
let <strong>print_name</strong> x =
    printf "%s %s" x.Name x.Surname
&nbsp;
let pepa =
    { ID = 42
      Name = "Josef"
      Surname = "Vyskočil"}
&nbsp;
&nbsp;
print_name pepa
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Chování algoritmu typové inference v&nbsp;případě dvou struktur se shodnými prvky</h2>

<p>Při pohledu na demonstrační příklad <a href="#k03">z&nbsp;předchozí
kapitoly</a> by se mohlo zdát, že algoritmus pro typovou inferenci odvozuje typ
parametrů funkcí podle toho, s&nbsp;jakými skutečnými hodnotami jsou funkce
volány. Ovšem snadno se můžeme přesvědčit, že to není (zcela) pravda.
V&nbsp;dalším skriptu jsou deklarovány dva datové typy <strong>User</strong> a
<strong>UserWithoutID</strong>, které mají položky se stejným jménem
<strong>Name</strong> a <strong>Surname</strong>. Ve funkci
<strong>print_name</strong> se pracuje jen s&nbsp;položkami
<strong>Name</strong> a <strong>Surname</strong>, takže typová inference
odvodí, že by se mohlo jednat o parametr typu <strong>UserWithoutID</strong>.
Ovšem ve skutečnosti bude funkce volána s&nbsp;parametrem typu
<strong>User</strong>, což vede k&nbsp;chybě při překladu:</p>

<pre>
type <strong>User</strong> = 
    { ID: int
      Name: string
      Surname: string}
&nbsp;
type <strong>UserWithoutID</strong> = 
    { Name: string
      Surname: string}
&nbsp;
let <strong>print_name</strong> x =
    printf "%s %s" x.Name x.Surname
&nbsp;
let pepa =
    { ID = 42
      Name = "Josef"
      Surname = "Vyskočil"}
&nbsp;
&nbsp;
<i>(* nefunkcni varianta *)</i>
print_name pepa
</pre>

<p>Řešením je explicitní specifikace typu parametru funkce
<strong>print_name</strong> (viz podtržená část kódu):</p>

<pre>
type <strong>User</strong> = 
    { ID: int
      Name: string
      Surname: string}
&nbsp;
type <strong>UserWithoutID</strong> = 
    { Name: string
      Surname: string}
&nbsp;
let <strong>print_name</strong> (<u>x:User</u>) =
    printf "%s %s" x.Name x.Surname
&nbsp;
let pepa =
    { ID = 42
      Name = "Josef"
      Surname = "Vyskočil"}
&nbsp;
&nbsp;
<i>(* funkcni varianta *)</i>
print_name pepa
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Datový typ výčet (<i>enum</i>)</h2>

<p>Dalším způsobem, jak v&nbsp;programovacím jazyku F# definovat datový typ, je
definice výčtu (<i>enum</i>). Je to snadné, protože pouze postačuje
specifikovat názvy a hodnoty jednotlivých prvků uložených ve výčtu. Hodnoty se
získají snadno &ndash; opět se použije tečková notace:</p>

<pre>
type <strong>Day</strong> = Po=1 | Ut=2 | St=3 | Ct=4 | Pa=5 | So=6 | Ne=7
&nbsp;
let x = Day.St
&nbsp;
printf "%A\n" x
</pre>

<p>Alternativní způsob zápisu výčtu vypadá takto (použitý je pro delší názvy či
hodnoty):</p>

<pre>
type Day =
     | Po=1
     | Ut=2
     | St=3
     | Ct=4
     | Pa=5
     | So=6
     | Ne=7
let x = Day.St
printf "%A\n" x
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě nejsme omezeni jen na hodnoty
typu celé číslo.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Datový typ disjunktní sjednocení (<i>discriminated union</i>)</h2>

<p>Velmi důležitým datovým typem je v&nbsp;programovacím jazyku F# typ nazývaný
disjunktní sjednocení neboli <i>discriminated union</i>. V&nbsp;té
nejjednodušší podobě může být tento typ definován pouhým výčtem možností:</p>

<pre>
type <strong>Day</strong> = Po | Ut | St | Ct | Pa | So | Ne
&nbsp;
let x = St
&nbsp;
printf "%A\n" x
</pre>

<p>Alternativní způsob zápisu:</p>

<pre>
type <strong>Day</strong> =
     | Po
     | Ut
     | St
     | Ct
     | Pa
     | So
     | Ne
let x = St
printf "%A\n" x
</pre>

<p>Až doposud by se mohlo zdát, že se vlastně jedná o typ výčet, ovšem možnosti
disjunktního sjednocení jsou mnohem větší. Již jsme se setkali s&nbsp;typy
<strong>Option</strong> a <strong>Result</strong>:</p>

<pre>
type <strong>Option&lt;'a&gt;</strong> =
   | Some of 'a
   | None
</pre>

<p>a:</p>

<pre>
type <strong>Result&lt;'T,'TError&gt;</strong> =
    | Ok of ResultValue:'T
    | Error of ErrorValue:'TError
</pre>

<p>Další podobné konstrukce budou uvedeny v&nbsp;navazujících kapitolách.</p>

<p><div class="rs-tip-major">Poznámka: jedná se o ukázku <i>součtových datových
typů</i>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. N-tice</h2>

<p>O tom, jak se vytváří hodnoty typu n-tice (<i>tuple</i>) jsme si již
v&nbsp;tomto seriálu říkali. Postačuje napsat například:</p>

<pre>
let x = <strong>(1, 1.5, "foo", (1,2)) ;;</strong>
</pre>

<p>přičemž výsledkem bude hodnota typu:</p>

<pre>
int * float * string * (int * int)
</pre>

<p>Za povšimnutí stojí především zápis * mezi typy jednotlivých prvků, což
napovídá, že na rozdíl předchozího typu se v&nbsp;tomto případě nejedná o
<i>součtový datový typ</i>, ale naopak o <i>součinový datový typ</i> (existuje
jen jedna varianta).</p>

<p>Konkrétní typ n-tice si samozřejmě můžeme snadno zadefinovat a může se tak
jednat o určitou alternativu k&nbsp;záznamům. V&nbsp;dalším příkladu je ukázán
neidiomatický způsob získání jednotlivých hodnot prvků z&nbsp;n-tice
s&nbsp;využitím vnořeného bloku <strong>let</strong>:</p>

<pre>
type <strong>Rectangle</strong> = int * int
&nbsp;
let <strong>print_rectange</strong> r =
    let (width, height) = r in
        printf "rect: %dx%d\n" width height
&nbsp;
let r1 = (10, 20)
&nbsp;
print_rectange r1
</pre>

<p><div class="rs-tip-major">Poznámka: pro jazyk F# je typické, že při pattern
matchingu je samotný vzorek (<i>pattern</i>) zapisován stejně jako konstruktor
daného typu. Tedy pokud se konstruktor zapisuje ve tvaru <strong>(položka1,
položka2)</strong> bude vzorek vypadat syntakticky stejně.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. N-tice a pattern matching</h2>

<p>Při čtení prvků z&nbsp;n-tice se mnohdy setkáme s&nbsp;využitím <i>pattern
matchingu</i>, který v&nbsp;tomto případě může mít jen jedinou větev. Podívejme
se na následující příklad, v&nbsp;němž z&nbsp;n-tice obsahující šířku a výšku
obdélníku získáme obě délky v&nbsp;samostatných lokálních proměnných
<strong>width</strong> a <strong>height</strong>:</p>

<pre>
type <strong>Rectangle</strong> = int * int
&nbsp;
let <strong>print_rectange</strong> (r : Rectangle) =
    match r with
    | (width, height) -&gt; printf "rect: %dx%d\n" width height
&nbsp;
let r1 = (10, 20)
&nbsp;
print_rectange r1
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Od n-tic k&nbsp;sofistikovanějším disjunktním sjednocením</h2>

<p>Mnohdy se taktéž setkáme s&nbsp;následujícím zápisem, který nás již
připravuje na seznámení se s&nbsp;dalšími možnostmi zápisu disjunktního
sjednocení (<i>discriminated union</i>) &ndash; viz další kapitoly:</p>

<pre>
type <strong>Rectangle</strong> = R of int * int
&nbsp;
let <strong>print_rectange</strong> (r : Rectangle) =
    match r with
    | R(width, height) -&gt; printf "rect: %dx%d\n" width height
&nbsp;
let r1 = R(10, 20)
&nbsp;
print_rectange r1
</pre>

<p>Můžeme dokonce rozlišit mezi jménem typu a jménem položky &ndash;
identifikátory jsou stejné, ovšem mají odlišný význam:</p>

<pre>
type <strong>Rectangle</strong> = Rectangle of int * int
&nbsp;
let <strong>print_rectange</strong> (r : Rectangle) =
    match r with
    | Rectangle(width, height) -&gt; printf "rect: %dx%d\n" width height
&nbsp;
let r1 = Rectangle(10, 20)
&nbsp;
print_rectange r1
</pre>

<p><div class="rs-tip-major">Poznámka: předchozí příklad ukazuji proto, že se
s&nbsp;ním lze setkat, i když je dosti matoucí. I když jazyk F# tento zápis
umožňuje, je vhodnější mít identifikátory s&nbsp;unikátními jmény, i když je
každý používán v&nbsp;jiném kontextu (tomu se ovšem v&nbsp;praxi stejně
nevyhneme).</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Disjunktní sjednocení s&nbsp;prvky typu n-tice</h2>

<p>Nyní se dostáváme k&nbsp;velmi důležitému rysu typového systému
programovacího jazyka F#. Můžeme totiž vytvořit nový datový typ umožňující
reprezentaci hodnoty, která sama o sobě může být různého typu. Typickým
příkladem je typ nazvaný <strong>Shape</strong>, který je disjunktním
sjednocením jednotlivých konkrétních typů (tvarů), například obdélníku a
kružnice:</p>

<pre>
type <strong>Shape</strong> = Rectangle of int * int | Circle of int
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že
<strong>Rectangle</strong> je n-tice zatímco <strong>Circle</strong> je datový
typ <strong>int</strong>.</div></p>

<p>Deklarace proměnných typu <strong>Shape</strong>:</p>

<pre>
let r1 = Rectangle (10, 20)
let c = Circle 100
</pre>

<p>Přidejme si ještě funkci, která bude hodnoty typu <strong>Shape</strong>
tisknout. Pro rozlišení konkrétního typu hodnoty použijeme pattern matching a
(opět) si povšimněte, že zápis na levé straně šipky syntakticky přesně odpovídá
deklaraci hodnoty uvedené výše:</p>

<pre>
type <strong>Shape</strong> = Rectangle of int * int | Circle of int
&nbsp;
let <strong>print_shape</strong> (s : Shape) =
    match s with
    | Circle r -&gt; printf "circle: %d\n" r
    | Rectangle (width, height) -&gt; printf "rect: %dx%d\n" width height
&nbsp;
let r1 = Rectangle (10, 20)
let c = Circle 100
&nbsp;
print_shape r1
print_shape c
</pre>

<p>Navíc v&nbsp;tomto případě můžeme typ parametru funkce
<strong>print_shape</strong> vynechat; tuto práci za nás udělá algoritmus pro
odvození typů (typovou inferenci):</p>

<pre>
let <strong>print_shape</strong> s =
    match s with
    | Circle r -&gt; printf "circle: %d\n" r
    | Rectangle (width, height) -&gt; printf "rect: %dx%d\n" width height
</pre>

<p>V&nbsp;praxi se namísto zápisu:</p>

<pre>
type <strong>Shape</strong> = Rectangle of int * int | Circle of int
</pre>

<p>mnohdy setkáme s&nbsp;rozdělením na více řádky:</p>

<pre>
type <strong>Shape</strong> = 
    | Circle of int
    | Rectangle of int * int
&nbsp;
let <strong>print_shape</strong> (s : Shape) =
    match s with
    | Circle r -&gt; printf "circle: %d\n" r
    | Rectangle (width, height) -&gt; printf "rect: %dx%d\n" width height
&nbsp;
let r1 = Rectangle (10, 20)
let c = Circle 100
&nbsp;
print_shape r1
print_shape c
</pre>

<p><div class="rs-tip-major">Poznámka: naposledy &ndash; definice typu
<strong>Shape</strong> nyní vizuálně do jisté míry odpovídá zápisu bloku
<strong>match</strong> nad tímtéž typem. Jedná se o další elegantní rys
programovacího jazyka F#.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rekurzivní a generické datové typy</h2>

<p>Disjunktní sjednocení zkombinované s&nbsp;n-ticemi ve skutečnosti
představuje velmi silný rys programovacího jazyka F#. Ten je navíc umocněn tím,
že je možné definovat i rekurzivní datový typ, kdy jedna z&nbsp;položek
sjednocení je typem obsahujícím samotné sjednocení. Zní to jako zcela
akademický problém? Podívejme se na příklad definice datového typu, který
reprezentuje výrazy (ne tak, jak jsou zapsány v&nbsp;kódu, ale jejich
inherentní rekurzivní podobu). Nový datový typ se jmenuje
<strong>expression</strong> a jedná se o disjunktní sjednocení pěti možností
&ndash; čtyř podvýrazů a názvu proměnných:</p>

<pre>
type <strong>expression</strong> =
    | Plus of expression * expression        <i>(* a + b *)</i>
    | Minus of expression * expression       <i>(* a - b *)</i>
    | Times of expression * expression       <i>(* a * b *)</i>
    | Divide of expression * expression      <i>(* a / b *)</i>
    | Var of string    
&nbsp;
let x = Times (Var "n", Plus (Var "x", Var "y"))
&nbsp;
printf "%A\n" x
</pre>

<p>Ovšem možnosti datového systému jazyka F# jdou ještě dále, protože můžeme
vytvořit generický datový typ. Tentokrát se bude jednat o datový typ
představující strom, což je rekurzivní struktura. Povšimněte si, že existují
dva typy prvků (uzlů). Prázdný (koncový uzel) nebo uzel představovaný n-ticí
obsahující levý podstrom, hodnotu uloženou v&nbsp;uzlu a pravý podstrom
(samozřejmě, že podstromy mohou být prázdné, takže se může jednat o list
stromu):</p>

<pre>
type Tree&lt;'a&gt; =
    | E
    | T of Tree&lt;'a&gt; * 'a * Tree&lt;'a&gt;
&nbsp;
let t1 = T(E, "foo", E)
let t2 = T(T(E, "foo", E), "bar", T(E, "baz", E))
&nbsp;
printf "%A\n" t1
&nbsp;
printf "%A\n" t2
</pre>

<p><div class="rs-tip-major">Poznámka: můžete si sami vyzkoušet jinou
reprezentaci stromu, například takovou, aby hodnoty byly uložené jen
v&nbsp;listech stromu (potom lze namísto prázdného uzlu použít přímo generickou
hodnotu, ostatní uzly budou obsahovat pouze podstromy).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Datový typ třída (<i>class</i>)</h2>

<p>Jazyk F# je odvozen z&nbsp;jazyka OCaml, kde &bdquo;O&ldquo; znamená
&bdquo;objective&ldquo;. Navíc musí F# spolupracovat s&nbsp;dalšími jazyky
v&nbsp;ekosystému .NET. Z&nbsp;obou vlastností vyplývá, že F# vlastně musí
podporovat objektově orientované programování, konkrétně OOP založené na
třídách (i když samotný F# je spíše funkcionálním jazykem). Podívejme se nyní
na deklaraci jednoduché třídy, jejíž instance budou mít dva atributy
<strong>X</strong> a <strong>Y</strong> (rozměry v&nbsp;jednotlivých osách) a
s&nbsp;konstruktorem, který akceptuje dva parametry typu <strong>int</strong>
(výchozí hodnoty rozměrů):</p>

<pre>
type <strong>Rectangle</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
&nbsp;
&nbsp;
<i>(* konstrukce objektu typu Rectangle *)</i>
let r1 = Rectangle(10, 20)
&nbsp;
printf "%A\n" r1
</pre>

<p>Do deklarace třídy můžeme přidat i metody. Například se může jednat o metodu
nazvanou <strong>Print</strong>, která vytiskne jak název objektu, tak i jeho
atributy:</p>

<pre>
type <strong>Rectangle</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
    member this.<strong>Print</strong>() =
        printf "Rectangle: %dx%d\n" this.X this.Y
&nbsp;
let r1 = Rectangle(10, 20)
&nbsp;
r1.Print()
</pre>

<p>Zajímavé ovšem je, že v&nbsp;metodě <strong>Print</strong> můžeme použít i
hodnotu původních parametrů konstruktoru (což je v&nbsp;případě neměnných
hodnot to stejné, jakoby se jednalo přímo o atributy objektu). Mnohdy se tedy
můžeme setkat se třídami, jejichž instance sice nesou informaci o svém stavu,
ale nemají deklarovány atributy:</p>

<pre>
type <strong>Rectangle</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d\n" <strong>x</strong> <strong>y</strong>
&nbsp;
let r1 = Rectangle(10, 20)
&nbsp;
r1.Print()
</pre>

<p><div class="rs-tip-major">Poznámka: vytvořte si více instancí třídy
<strong>Rectangle</strong> pro ověření, zda je vše funkční.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Lokální symbol v&nbsp;deklaraci třídy</h2>

<p>Již <a href="#k12">v&nbsp;předchozí kapitole</a> jsme mohli vidět použití
parametrů předaných konstruktoru uvnitř třídy. Programovací jazyk F# dokonce
umožňuje deklaraci lokálního symbolu při konstrukci třídy; tedy hodnota
navázaná na symbol bude dostupná ve vytvořeném objektu. Například si můžeme
spočítat plochu obdélníka a uložit si ji do lokálního symbolu
<strong>area</strong>. Hodnota je posléze použita v&nbsp;metodě
<strong>Print</strong>:</p>

<pre>
type Rectangle(x: int, y: int) =
    let <strong>area</strong> = x * y
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d with area %d\n" x y <strong>area</strong>
&nbsp;
let r1 = Rectangle(10, 20)
&nbsp;
r1.Print()
</pre>

<p>Samozřejmě si opět můžeme metodu <strong>Print</strong> upravit tak, aby
četla hodnoty atributů:</p>

<pre>
type Rectangle(x: int, y: int) =
    let <strong>area</strong> = x * y
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d with area %d\n" this.X this.Y <strong>area</strong>
&nbsp;
let r1 = Rectangle(10, 20)
&nbsp;
r1.Print()
</pre>

<p>Lokální symbol nelze, na rozdíl od atributů, číst vně definice třídy. To
znamená, že následující program nebude přeložitelný kvůli podtrženým
řádkům:</p>

<pre>
type <strong>Rectangle</strong>(x: int, y: int) =
    let area = x * y
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d %d\n" x y area
&nbsp;
let r1 = Rectangle(10, 20)
let r2 = Rectangle(1, 2)
&nbsp;
printf "%d\n" r1.X
printf "%d\n" r1.Y
<u>printf "%d\n" r1.area</u>
&nbsp;
printf "%d\n" r2.X
printf "%d\n" r2.Y
<u>printf "%d\n" r2.area</u>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Konstrukce nové instance třídy realizovaná v&nbsp;metodě</h2>

<p>Atributy objektů jsou, pokud ovšem nebudeme explicitně žádat o jiné chování,
neměnitelné (<i>immutable</i>), což je v&nbsp;mnoha ohledech výhoda. Relativně
často se ovšem setkáme s&nbsp;tím, že nějaká metoda má změnit stav objektu,
tj.&nbsp;vlastně hodnoty jeho atributů. To lze samozřejmě zařídit tak, že se
příslušné atributy deklarují takovým způsobem, aby byly měnitelné. Ovšem mnohdy
je výhodnější použít odlišný přístup &ndash; taková metoda bude vracet nový
objekt, ovšem již se změněným stavem. Příkladem může být požadavek na změnu
velikosti obdélníka, tedy získání obdélníka, jehož rozměry na x-ové a y-ové ose
budou zvětšeny nebo zmenšeny o nějaké hodnoty <strong>dx</strong> a
<strong>dy</strong>. Pro tento účel lze deklarovat metodu
<strong>Enlarge</strong>, která vrací novou instanci <strong>Rectangle</strong>
(ale stávající instanci nijak nemění):</p>

<pre>
type <strong>Rectangle</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d\n" this.X this.Y
    member this.Enlarge(dx, dy) =
        Rectangle(this.X + dx, this.Y + dy)
</pre>

<p>Chování takto deklarované třídy si můžeme snadno ověřit například na tomto
kódu:</p>

<pre>
let r1 = Rectangle(10, 20)
r1.Print()
&nbsp;
let r2 = r1.Enlarge(1, 2)
&nbsp;
r1.Print()
r2.Print()
</pre>

<p><div class="rs-tip-major">Poznámka: obdélník <strong>r1</strong> je vytištěn
dvakrát, aby bylo patrné, jak ho zavolání metody <strong>Enlarge</strong>
změnilo či naopak nezměnilo.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Operátory definované v&nbsp;rámci uživatelského datového typu</h2>

<p><a
href="https://www.root.cz/clanky/operatory-v-programovacim-jazyku-f/">V&nbsp;předchozím
článku</a> jsme se seznámili s&nbsp;tím, jakým způsobem je v&nbsp;programovacím
jazyku F# umožněno definovat nové operátory popř.&nbsp;změnit chování
existujících operátorů. Ovšem prozatím jsme se věnovali jen operátorům na
globální úrovni (resp.&nbsp;na úrovni jednotlivých modulů, o tom však až
příště). V&nbsp;praxi je však mnohem užitečnější definice operátoru
v&nbsp;rámci určité třídy. Například si můžeme nadefinovat třídu reprezentující
dvousložkový vektor:</p>

<pre>
type <strong>Vector</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
</pre>

<p>Pro tuto třídu, resp.&nbsp;přesněji řečeno pro instance této třídy, lze
přetížit standardní operátor + tak, aby skutečně prováděl součet dvou vektorů a
vracel vektor nový:</p>

<pre>
static member (+) (a : Vector, b : Vector) =
    Vector(a.X + b.X, a.Y + b.Y)
</pre>

<p>Takto vypadá třída <strong>Vector</strong> s&nbsp;definicí přetíženého
operátoru:</p>

<pre>
type <strong>Vector</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Vector: %dx%d\n" this.X this.Y
    static member (+) (a : Vector, b : Vector) =
        Vector(a.X + b.X, a.Y + b.Y)
&nbsp;
let v1 = Vector(10, 20)
v1.Print()
&nbsp;
let v2 = Vector(1, 2)
v2.Print()
&nbsp;
let v3 = v1 + v2
v3.Print()
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně zůstaly původní vlastnosti
operátoru + zachovány pro ty datové typy, pro které byl operátor navržen (celá
čísla, řetězce atd.).</div></p>

<p>Typicky u přetížených operátorů, ale i u dalších malých metod, může být
výhodné použít modifikátor <strong>inline</strong>, který může vést
k&nbsp;vygenerování rychlejšího strojového kódu. Úprava předchozího
demonstračního příkladu je v&nbsp;tomto případě snadná:</p>

<pre>
type <strong>Vector</strong>(x: int, y: int) =
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Vector: %dx%d\n" this.X this.Y
    static member <u>inline</u> (+) (a : Vector, b : Vector) =
        Vector(a.X + b.X, a.Y + b.Y)
&nbsp;
let v1 = Vector(10, 20)
v1.Print()
&nbsp;
let v2 = Vector(1, 2)
v2.Print()
&nbsp;
let v3 = v1 + v2
v3.Print()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Dědičnost</h2>

<p>Posledním tématem, kterému se dnes budeme alespoň ve stručnosti věnovat, je
realizace dědičnosti v&nbsp;programovacím jazyku F#. Ukažme si její využití na
jednoduchém příkladu, v&nbsp;němž je definována nadtřída nazvaná
<strong>Shape</strong>, ze které je odvozena třída <strong>Rectangle</strong>
(povšimněte si řádku začínajícího klíčovým slovem
<strong>inherit</strong>):</p>

<pre>
type <strong>Shape</strong>() =
    member this.Print() = ()
&nbsp;
type <strong>Rectangle</strong>(x: int, y: int) =
    <u>inherit Shape()</u>
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d\n" this.X this.Y
    member this.Enlarge(dx, dy) =
        Rectangle(this.X + dx, this.Y + dy)
&nbsp;
let r1 = Rectangle(10, 20)
r1.Print()
&nbsp;
let r2 = r1.Enlarge(1, 2)
r2.Print()
</pre>

<p><div class="rs-tip-major">Poznámka: třída <strong>Shape</strong> není
definována jako abstraktní, takže lze vytvořit její instanci. A pokud si to
chcete ověřit, je lepší změnit její metodu <strong>Print</strong>:</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: případné volání konstruktoru
nadtřídy se provádí právě na řádku <strong>inherit</strong>.</div></p>

<pre>
type <strong>Shape</strong>() =
    member this.Print() = printf "Shapeless shape"
</pre>

<p>Samozřejmě je možné z&nbsp;jedné nadtřídy odvodit více podtříd, takže se
vytváří klasická hierarchie tříd:</p>

<pre>
type <strong>Shape</strong>() =
    member this.Print() = ()
&nbsp;
type <strong>Circle</strong>(r: int) =
    inherit Shape()
    member this.R = r
    member this.Print() =
        printf "Circle: %d\n" this.R
    member this.Enlarge(dr) =
        Circle(this.R + dr)
&nbsp;
type <strong>Rectangle</strong>(x: int, y: int) =
    inherit Shape()
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d\n" this.X this.Y
    member this.Enlarge(dx, dy) =
        Rectangle(this.X + dx, this.Y + dy)
&nbsp;
let r1 = Rectangle(10, 20)
r1.Print()
&nbsp;
let r2 = r1.Enlarge(1, 2)
r2.Print()
&nbsp;
let c1 = Circle(10)
c1.Print()
&nbsp;
let c2 = c1.Enlarge(1)
c2.Print()
</pre>

<p><div class="rs-tip-major">Poznámka: pokud pracujete s&nbsp;programovacím
jazykem založeným na třídním OOP, asi vás napadlo, jaké nedostatky předchozí
kód obsahuje. Postupně je budeme &bdquo;vychytávat&ldquo;.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Operátor <strong>upcast</strong>: přetypování na předka</h2>

<p>V&nbsp;programovacím jazyku F# nalezneme mj.&nbsp;i dva
&bdquo;šipkové&ldquo; operátory, které jsme <a
href="https://www.root.cz/clanky/operatory-v-programovacim-jazyku-f/#k10">minule</a>
vynechali. Jeden z&nbsp;těchto operátorů se zapisuje znakem :&gt; a provádí
konverzi hodnoty na třídu, která se v&nbsp;hierarchii nachází výše.
Z&nbsp;tohoto důvodu se tento operátor nazývá <i>upcast</i>.</p>

<p>Podívejme se nyní na základní způsob použití tohoto operátoru. Použijeme
naši hierarchii tříd <strong>Shape:Circle</strong> a
<strong>Shape:Rectangle</strong>:</p>

<pre>
type <strong>Shape</strong>() =
    member this.Print() = printf "Shapeless shape"
&nbsp;
type <strong>Circle</strong>(r: int) =
    inherit Shape()
    member this.R = r
    member this.Print() =
        printf "Circle: %d\n" this.R
    member this.Enlarge(dr) =
        Circle(this.R + dr)
&nbsp;
type <strong>Rectangle</strong>(x: int, y: int) =
    inherit Shape()
    member this.X = x
    member this.Y = y
    member this.Print() =
        printf "Rectangle: %dx%d\n" this.X this.Y
    member this.Enlarge(dx, dy) =
        Rectangle(this.X + dx, this.Y + dy)
</pre>

<p>Necháme si zkonstruovat několik instancí tříd <strong>Rectangle</strong> a
<strong>Circle</strong>:</p>

<pre>
let r1 = Rectangle(10, 20)
r1.Print()
&nbsp;
let r2 = r1.Enlarge(1, 2)
r2.Print()
&nbsp;
let c1 = Circle(10)
c1.Print()
&nbsp;
let c2 = c1.Enlarge(1)
c2.Print()
</pre>

<p>Další objekt bude získán z&nbsp;instance <strong>r1</strong>, ale bude
přetypován na instanci třídy <strong>Shape</strong>:</p>

<pre>
let s1 = r1 :&gt; Shape
s1.Print()
</pre>

<p>Výsledky ukazují, jak bude vše probíhat v&nbsp;runtime:</p>

<pre>
Rectangle: 10x20
Rectangle: 11x22
Circle: 10
Circle: 11
Shapeless shape
</pre>

<p>Existuje i operátor <i>downcast</i> zapisovaný znaky :?&gt;. Jeho chování je
v&nbsp;praxi poněkud složitější a proto se k&nbsp;němu ještě vrátíme
v&nbsp;dalším článku:</p>

<pre>
let s2 = s1 :?&gt; Rectangle
s2.Print()
&nbsp;
let s3 = s1 :?&gt; Circle
s3.Print()
</pre>

<p>Tato část kódu po svém překladu a spuštění vypíše:</p>

<pre>
Rectangle: 10x20
Circle: undefined
</pre>

<p><div class="rs-tip-major">Poznámka: jak sami vidíte, problematická je
zejména druhá konverze. Konkrétně jsme z&nbsp;instance třídy
<strong>Rectangle</strong> udělali instanci třídy <strong>Shape</strong> a
posléze instanci třídy <strong>Circle</strong>, což pochopitelně bez dalších
podpůrných částí kódu nemůže pracovat korektně.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/f-sharp-examples/">https://github.com/tisnik/f-sharp-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>ML/fib_recursive.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti rekurzivně</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_recursive.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_recursive.ml</a></td></tr>
<tr><td> 2</td><td>ML/fib_pattern_matching.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_pattern_matching.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/fib_pattern_matching.ml</a></td></tr>
<tr><td> 3</td><td>ML/len_pattern_matching_1.ml</td><td>výpočet délky seznamu založený na pattern matchingu (první varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_1.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_1.ml</a></td></tr>
<tr><td> 4</td><td>ML/len_pattern_matching_2.ml</td><td>výpočet délky seznamu založený na pattern matchingu (zkrácená varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_2.ml">https://github.com/tisnik/f-sharp-examples/tree/master/ML/len_pattern_matching_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>OCaml/fib_recursive.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti rekurzivně</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_recursive.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_recursive.ml</a></td></tr>
<tr><td> 6</td><td>OCaml/fib_tail_recursive.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti s&nbsp;využitím koncové rekurze</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_tail_recursive.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_tail_recursive.ml</a></td></tr>
<tr><td> 7</td><td>OCaml/fib_pattern_matching.ml</td><td>výpočet hodnoty z&nbsp;Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_pattern_matching.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/fib_pattern_matching.ml</a></td></tr>
<tr><td> 8</td><td>OCaml/local_binding.ml</td><td>symbol lokální uvnitř funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/local_binding.ml">https://github.com/tisnik/f-sharp-examples/tree/master/OCaml/local_binding.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>article_01/function.fs</td><td>deklarace pojmenované funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function.fs</a></td></tr>
<tr><td>10</td><td>article_01/lambda.fs</td><td>deklarace anonymní funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/lambda.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/lambda.fs</a></td></tr>
<tr><td>11</td><td>article_01/local_binding_1.fs</td><td>lokální symboly ve funkci</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_1.fs</a></td></tr>
<tr><td>12</td><td>article_01/local_binding_2.fs</td><td>lokální symboly ve funkci</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/local_binding_2.fs</a></td></tr>
<tr><td>13</td><td>article_01/function_type_1.fs</td><td>explicitní definice návratového typu funkce (korektní)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_1.fs</a></td></tr>
<tr><td>14</td><td>article_01/function_type_2.fs</td><td>explicitní definice návratového typu funkce (nekorektní)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_01/function_type_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>article_02/basic_binding.fs</td><td>navázání hodnoty na symbol (deklarace proměnné)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fs</a></td></tr>
<tr><td>16</td><td>article_02/print_variable.fs</td><td>tisk hodnoty proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fs</a></td></tr>
<tr><td>17</td><td>article_02/variables_and_functions.fs</td><td>předání proměnné do funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fs</a></td></tr>
<tr><td>18</td><td>article_02/redefine_symbol_1.fs</td><td>pokus o redefinici symbolu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fs</a></td></tr>
<tr><td>19</td><td>article_02/redefine_symbol_2.fs</td><td>pokus o redefinici symbolu (složitější příklad)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>article_02/equal_operator_1.fs</td><td>operátor =</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fs</a></td></tr>
<tr><td>21</td><td>article_02/equal_operator_2.fs</td><td>operátor =</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>article_02/immutable_variable.fs</td><td>&bdquo;změna&ldquo; neměnitelné proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fs</a></td></tr>
<tr><td>23</td><td>article_02/mutable_variable.fs</td><td>změna měnitelné proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fs</a></td></tr>
<tr><td>24</td><td>article_02/reference_1.fs</td><td>reference, příklad kompatibilní s&nbsp;OCamlem</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fs</a></td></tr>
<tr><td>25</td><td>article_02/reference_2.fs</td><td>reference, nová syntaxe pro F#</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fs</a></td></tr>
<tr><td>26</td><td>article_02/incr1.fs</td><td>standardní funkce <strong>incr</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fs</a></td></tr>
<tr><td>27</td><td>article_02/incr2.fs</td><td>zvýšení referencované hodnoty o jedničku</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fs</a></td></tr>
<tr><td>28</td><td>article_02/shadow.fs</td><td>shadowing symbolu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/shadow.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/shadow.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>article_02/tuple.fs</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/tuple.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/tuple.fs</a></td></tr>
<tr><td>30</td><td>article_02/record_1.fs</td><td>datový typ záznam (<i>record</i>), deklarace proměnné tohoto typu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_1.fs</a></td></tr>
<tr><td>31</td><td>article_02/record_2.fs</td><td>datový typ záznam (<i>record</i>) a typová inference při deklaraci proměnné</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/record_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>article_02/basic_binding.fsx</td><td>demonstrační příklad <strong>basic_binding.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/basic_binding.fsx</a></td></tr>
<tr><td>33</td><td>article_02/equal_operator_1.fsx</td><td>demonstrační příklad <strong>equal_operator_1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_1.fsx</a></td></tr>
<tr><td>34</td><td>article_02/equal_operator_2.fsx</td><td>demonstrační příklad <strong>equal_operator_2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/equal_operator_2.fsx</a></td></tr>
<tr><td>35</td><td>article_02/immutable_variable.fsx</td><td>demonstrační příklad <strong>immutable_variable.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/immutable_variable.fsx</a></td></tr>
<tr><td>36</td><td>article_02/mutable_variable.fsx</td><td>demonstrační příklad <strong>mutable_variable.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/mutable_variable.fsx</a></td></tr>
<tr><td>37</td><td>article_02/print_variable.fsx</td><td>demonstrační příklad <strong>print_variable.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/print_variable.fsx</a></td></tr>
<tr><td>38</td><td>article_02/redefine_symbol_1.fsx</td><td>demonstrační příklad <strong>redefine_symbol_1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_1.fsx</a></td></tr>
<tr><td>39</td><td>article_02/redefine_symbol_2.fsx</td><td>demonstrační příklad <strong>redefine_symbol_2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/redefine_symbol_2.fsx</a></td></tr>
<tr><td>40</td><td>article_02/variables_and_functions.fsx</td><td>demonstrační příklad <strong>variables_and_functions.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/variables_and_functions.fsx</a></td></tr>
<tr><td>41</td><td>article_02/incr1.fsx</td><td>demonstrační příklad <strong>incr1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr1.fsx</a></td></tr>
<tr><td>42</td><td>article_02/incr2.fsx</td><td>demonstrační příklad <strong>incr2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/incr2.fsx</a></td></tr>
<tr><td>43</td><td>article_02/reference_1.fsx</td><td>demonstrační příklad <strong>reference_1.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_1.fsx</a></td></tr>
<tr><td>44</td><td>article_02/reference_2.fsx</td><td>demonstrační příklad <strong>reference_2.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/reference_2.fsx</a></td></tr>
<tr><td>45</td><td>article_02/ident.fsx</td><td>demonstrační příklad <strong>ident.fs</strong> přepsaný do podoby skriptu pro <i>dotnet fsi</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_02/ident.fsx">https://github.com/tisnik/f-sharp-examples/tree/master/article_02/ident.fsx</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>article_03/recursion1.fs</td><td>pokus o deklaraci funkce s&nbsp;přímou rekurzí založený na <strong>let</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion1.fs</a></td></tr>
<tr><td>47</td><td>article_03/recursion2.fs</td><td>deklarace funkce s&nbsp;přímou rekurzí založená na <strong>let rec</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion2.fs</a></td></tr>
<tr><td>48</td><td>article_03/recursion3.fs</td><td>využití tail rekurze pro výpočet členu Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion3.fs</a></td></tr>
<tr><td>49</td><td>article_03/recursion4.fs</td><td>obyčejná nerekurzivní funkce definovaná přes <strong>let rec</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/recursion4.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>article_03/odd_even_1.fs</td><td>nepřímá rekurze (nekorektní varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_1.fs</a></td></tr>
<tr><td>51</td><td>article_03/odd_even_2.fs</td><td>nepřímá rekurze (taktéž nekorektní varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_2.fs</a></td></tr>
<tr><td>52</td><td>article_03/odd_even_3.fs</td><td>jediný korektní zápis nepřímé rekurze</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_3.fs</a></td></tr>
<tr><td>53</td><td>article_03/odd_even_4.fs</td><td>nepřímá rekurze bez použití klíčového slova <strong>rec</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/odd_even_4.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>article_03/pattern1.fs</td><td>výpočet Faktoriálu založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern1.fs</a></td></tr>
<tr><td>55</td><td>article_03/pattern2.fs</td><td>výpočet Faktoriálu založený na pattern matchingu, sloučení vstupů se stejným výstupem</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern2.fs</a></td></tr>
<tr><td>56</td><td>article_03/pattern3.fs</td><td>kontrola neplatného vstupu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern3.fs</a></td></tr>
<tr><td>57</td><td>article_03/pattern4.fs</td><td>pattern matching pro větší množství hodnot</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern4.fs</a></td></tr>
<tr><td>58</td><td>article_03/pattern5.fs</td><td>rekurzivní implementace Ackermannovy funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern5.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern5.fs</a></td></tr>
<tr><td>59</td><td>article_03/pattern6.fs</td><td>kontrola neplatných vstupních hodnot pro Ackermannovu funkci</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern6.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/pattern6.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 60</td><td>article_03/fibonacci1.fs</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/fibonacci1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/fibonacci1.fs</a></td></tr>
<tr><td> 61</td><td>article_03/fibonacci2.fs</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu (více idiomatický zápis)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/fibonacci2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/fibonacci2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 62</td><td>article_03/first.fs</td><td>funkce vracející první prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/first.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/first.fs</a></td></tr>
<tr><td> 63</td><td>article_03/second.fs</td><td>funkce vracející druhý prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/second.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/second.fs</a></td></tr>
<tr><td> 64</td><td>article_03/zero_coordinate.fs</td><td>test na nulovou souřadnici/souřadnice založený na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/zero_coordinate.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/zero_coordinate.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 65</td><td>article_03/get_model.fs</td><td>získání prvku ze záznamu (opět založeno na pattern matchingu)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_03/get_model.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_03/get_model.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 66</td><td>article_04/list_literal_1.fs</td><td>seznam se třemi prvky typu celé číslo</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_1.fs</a></td></tr>
<tr><td> 67</td><td>article_04/list_literal_2.fs</td><td>seznam se třemi prvky typu řetězec</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_2.fs</a></td></tr>
<tr><td> 68</td><td>article_04/list_literal_3.fs</td><td>seznam se třemi prvky typu n-tice</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_3.fs</a></td></tr>
<tr><td> 69</td><td>article_04/list_literal_4.fs</td><td>nekorektní pokus o vytvoření seznamu s&nbsp;prvky různých typů</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_literal_4.fs</a></td></tr>
<tr><td> 70</td><td>article_04/empty_list.fs</td><td>konstrukce prázdného seznamu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/empty_list.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/empty_list.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 71</td><td>article_04/head_tail_1.fs</td><td>složení seznamu se dvěma prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/head_tail_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/head_tail_1.fs</a></td></tr>
<tr><td> 72</td><td>article_04/head_tail_2.fs</td><td>složení seznamu se třemi prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/head_tail_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/head_tail_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 73</td><td>article_04/list_properties.fs</td><td>vlastnosti (<i>properties</i>) seznamů</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_properties.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/list_properties.fs</a></td></tr>
<tr><td> 74</td><td>article_04/len_1.fs</td><td>naivní rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/len_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/len_1.fs</a></td></tr>
<tr><td> 75</td><td>article_04/len_2.fs</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/len_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/len_2.fs</a></td></tr>
<tr><td> 76</td><td>article_04/len_3.fs</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/len_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/len_3.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 77</td><td>article_04/range_1.fs</td><td>vytvoření sekvence numerických hodnot s&nbsp;využitím operátoru <strong>range</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_1.fs</a></td></tr>
<tr><td> 78</td><td>article_04/range_2.fs</td><td>vytvoření sekvence numerických hodnot s&nbsp;využitím operátoru <strong>range</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_2.fs</a></td></tr>
<tr><td> 79</td><td>article_04/range_3.fs</td><td>vytvoření sekvence numerických hodnot s&nbsp;využitím operátoru <strong>range</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_3.fs</a></td></tr>
<tr><td> 80</td><td>article_04/range_4.fs</td><td>vytvoření sekvence numerických hodnot s&nbsp;využitím operátoru <strong>range</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/range_4.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 81</td><td>article_04/join_lists.fs</td><td>spojení dvou seznamů operátorem <strong>::</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/join_lists.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/join_lists.fs</a></td></tr>
<tr><td> 82</td><td>article_04/append_1.fs</td><td>implementace spojení dvou seznamů rekurzivním výpočtem</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/append_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/append_1.fs</a></td></tr>
<tr><td> 83</td><td>article_04/append_2.fs</td><td>implementace spojení dvou seznamů rekurzivním výpočtem, použití pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/append_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/append_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 84</td><td>article_04/sum_1.fs</td><td>součet hodnot všech prvků v&nbsp;seznamu (bez tail rekurze)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/sum_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/sum_1.fs</a></td></tr>
<tr><td> 85</td><td>article_04/sum_2.fs</td><td>součet hodnot všech prvků v&nbsp;seznamu (s&nbsp;využitím tail rekurze)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_04/sum_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_04/sum_2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 86</td><td>article_05/option_type.fs</td><td>definice datového typu <strong>Option</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_type.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_type.fs</a></td></tr>
<tr><td> 87</td><td>article_05/none_value.fs</td><td>hodnota <strong>None</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/none_value.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/none_value.fs</a></td></tr>
<tr><td> 88</td><td>article_05/some_value1.fs</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/some_value1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/some_value1.fs</a></td></tr>
<tr><td> 89</td><td>article_05/some_value2.fs</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/some_value2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/some_value2.fs</a></td></tr>
<tr><td> 90</td><td>article_05/option_value.fs</td><td>přístup k&nbsp;zapouzdřené hodnotě přes <strong>Option.Value</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_value.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_value.fs</a></td></tr>
<tr><td> 91</td><td>article_05/is_none_is_some1.fs</td><td>detekce, zda je hodnota <strong>Option</strong> rovna <strong>None</strong> či <strong>Some</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/is_none_is_some1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/is_none_is_some1.fs</a></td></tr>
<tr><td> 92</td><td>article_05/is_none_is_some2.fs</td><td>detekce, zda je hodnota <strong>Option</strong> rovna <strong>None</strong> či <strong>Some</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/is_none_is_some2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/is_none_is_some2.fs</a></td></tr>
<tr><td> 93</td><td>article_05/option_exists1.fs</td><td>základní pattern matching, korektní varianta</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_exists1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_exists1.fs</a></td></tr>
<tr><td> 94</td><td>article_05/option_exists2.fs</td><td>základní pattern matching, nekorektní varianta</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_exists2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_exists2.fs</a></td></tr>
<tr><td> 95</td><td>article_05/option_exists3.fs</td><td>základní pattern matching, nekorektní varianta</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_exists3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/option_exists3.fs</a></td></tr>
<tr><td> 96</td><td>article_05/find_in_list1.fs</td><td>vyhledávání prvku v&nbsp;seznamu založené na pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/find_in_list1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/find_in_list1.fs</a></td></tr>
<tr><td> 97</td><td>article_05/find_in_list2.fs</td><td>varianta předchozího programu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/find_in_list2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/find_in_list2.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 98</td><td>article_05/result_type.fs</td><td>definice datového typu <strong>Result</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_type.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_type.fs</a></td></tr>
<tr><td> 99</td><td>article_05/result_divide1.fs</td><td>ukázka použití datového typu <strong>Result</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide1.fs</a></td></tr>
<tr><td>100</td><td>article_05/result_divide2.fs</td><td>ukázka použití datového typu <strong>Result</strong> a pattern matchingu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide2.fs</a></td></tr>
<tr><td>101</td><td>article_05/result_divide3.fs</td><td>stejné jako result_divide1.fs, ovšem bez explicitního zápisu typů</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide3.fs</a></td></tr>
<tr><td>102</td><td>article_05/result_divide4.fs</td><td>stejné jako result_divide2.fs, ovšem bez explicitního zápisu typů</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/result_divide4.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>103</td><td>article_05/array_value.fs</td><td>deklarace pole výčtem jeho prvků</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_value.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_value.fs</a></td></tr>
<tr><td>104</td><td>article_05/array_create.fs</td><td>funkce <strong>Array.create</strong> pro konstrukci pole</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_create.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_create.fs</a></td></tr>
<tr><td>105</td><td>article_05/array_init1.fs</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_init1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_init1.fs</a></td></tr>
<tr><td>106</td><td>article_05/array_init2.fs</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_init2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_init2.fs</a></td></tr>
<tr><td>107</td><td>article_05/array_indexing.fs</td><td>indexování prvků pole</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_indexing.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_indexing.fs</a></td></tr>
<tr><td>108</td><td>article_05/array_mutation.fs</td><td>mutace pole: modifikace hodnot jeho prvků</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_mutation.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_mutation.fs</a></td></tr>
<tr><td>109</td><td>article_05/array_zerocreate.fs</td><td>konstrukce pole s&nbsp;nulovými prvky</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_zerocreate.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_05/array_zerocreate.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>110</td><td>article_06/unary_ops1.fs</td><td>unární aritmetické operátory a datový typ <strong>int</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/unary_ops1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/unary_ops1.fs</a></td></tr>
<tr><td>111</td><td>article_06/unary_ops2.fs</td><td>unární aritmetické operátory a datový typ <strong>float</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/unary_ops2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/unary_ops2.fs</a></td></tr>
<tr><td>112</td><td>article_06/binary_ops.fs</td><td>binární aritmetické operátory a datový typ <strong>int</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/binary_ops.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/binary_ops.fs</a></td></tr>
<tr><td>113</td><td>article_06/boolean.fs</td><td>Booleovské unární i binární operátory</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/boolean.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/boolean.fs</a></td></tr>
<tr><td>114</td><td>article_06/relational_1.fs</td><td>relační operátory, porovnání hodnot typu <strong>int</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_1.fs</a></td></tr>
<tr><td>115</td><td>article_06/relational_2.fs</td><td>relační operátory, porovnání hodnot typu <strong>string</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_2.fs</a></td></tr>
<tr><td>116</td><td>article_06/relational_3.fs</td><td>relační operátory, porovnání hodnot typu <strong>array</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_3.fs</a></td></tr>
<tr><td>117</td><td>article_06/relational_4.fs</td><td>relační operátory, porovnání hodnot typu <strong>array</strong></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/relational_4.fs</a></td></tr>
<tr><td>118</td><td>article_06/bit_operators.fs</td><td>operátory provádějící operaci bit po bitu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/bit_operators.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/bit_operators.fs</a></td></tr>
<tr><td>119</td><td>article_06/shifts.fs</td><td>operátory pro bitové a aritmetické posuny</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/shifts.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/shifts.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>120</td><td>article_06/func_pipeline_1.fs</td><td>kolona funkcí vytvořená operátorem |&gt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_1.fs</a></td></tr>
<tr><td>121</td><td>article_06/func_pipeline_2.fs</td><td>kolona funkcí vytvořená operátorem &lt;|</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_2.fs</a></td></tr>
<tr><td>122</td><td>article_06/func_pipeline_3.fs</td><td>kolona funkcí vytvořená operátorem ||&gt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_3.fs</a></td></tr>
<tr><td>123</td><td>article_06/func_pipeline_4.fs</td><td>kolona funkcí vytvořená operátorem ||&gt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_4.fs</a></td></tr>
<tr><td>124</td><td>article_06/func_pipeline_5.fs</td><td>kolona funkcí vytvořená operátorem |||&gt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_5.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_pipeline_5.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>125</td><td>article_06/func_composition_1.fs</td><td>kompozice dvou funkcí operátorem &gt;&gt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_composition_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_composition_1.fs</a></td></tr>
<tr><td>126</td><td>article_06/func_composition_2.fs</td><td>kompozice dvou funkcí operátorem &lt;&lt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_composition_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_composition_2.fs</a></td></tr>
<tr><td>127</td><td>article_06/func_composition_3.fs</td><td>kompozice tří funkcí operátorem &gt;&gt;</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_composition_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/func_composition_3.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>128</td><td>article_06/new_operator_1.fs</td><td>definice nového binárního operátoru</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_1.fs</a></td></tr>
<tr><td>129</td><td>article_06/new_operator_2.fs</td><td>přepis stávajícího binárního operátoru</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_2.fs</a></td></tr>
<tr><td>130</td><td>article_06/new_operator_3.fs</td><td>rozlišení unárního a binárního operátoru</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_3.fs</a></td></tr>
<tr><td>131</td><td>article_06/new_operator_4.fs</td><td>rozlišení unárního a binárního operátoru</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_4.fs</a></td></tr>
<tr><td>132</td><td>article_06/new_operator_5.fs</td><td>otestování asociativity operátoru</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_5.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_06/new_operator_5.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>133</td><td>article_07/circle_rectangle_1.fs</td><td>datový typ přestavující buď kružnici nebo obdélník</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/circle_rectangle_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/circle_rectangle_1.fs</a></td></tr>
<tr><td>134</td><td>article_07/circle_rectangle_2.fs</td><td>datový typ přestavující buď kružnici nebo obdélník</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/circle_rectangle_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/circle_rectangle_2.fs</a></td></tr>
<tr><td>135</td><td>article_07/discriminated_union.fs</td><td>použití datového typu <i>discriminated union</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/discriminated_union.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/discriminated_union.fs</a></td></tr>
<tr><td>136</td><td>article_07/enum_1.fs</td><td>příklad použití datového typu <i>výčet</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/enum.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/enum.fs</a></td></tr>
<tr><td>137</td><td>article_07/enum_2.fs</td><td>příklad použití datového typu <i>výčet</i></td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/enum.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/enum.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>138</td><td>article_07/rectangle_1.fs</td><td>typ Rectangle založený na n-tici</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_1.fs</a></td></tr>
<tr><td>139</td><td>article_07/rectangle_2.fs</td><td>úprava předchozího příkladu; pattern matching</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_2.fs</a></td></tr>
<tr><td>140</td><td>article_07/rectangle_3.fs</td><td>úprava předchozího příkladu, explicitní pojmenování</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_3.fs</a></td></tr>
<tr><td>141</td><td>article_07/rectangle_4.fs</td><td>různé jmenné prostory</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/rectangle_4.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>142</td><td>article_07/struct_type_1.fs</td><td>definice záznamu (record, struct)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_1.fs</a></td></tr>
<tr><td>143</td><td>article_07/struct_type_2.fs</td><td>rozšíření o funkci pro tisk záznamu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_2.fs</a></td></tr>
<tr><td>144</td><td>article_07/struct_type_3.fs</td><td>automatické odvození datového typu parametru funkce</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_3.fs</a></td></tr>
<tr><td>145</td><td>article_07/struct_type_4.fs</td><td>otestování mezí automatického odvozování typů parametrů (nefunkční varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_4.fs</a></td></tr>
<tr><td>146</td><td>article_07/struct_type_5.fs</td><td>otestování mezí automatického odvozování typů parametrů (funkční varianta)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_5.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/struct_type_5.fs</a></td></tr>
<tr><td>147</td><td>article_07/tree.fs</td><td>datový typ představující rekurzivní definici binárního stromu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/tree.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/tree.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>148</td><td>article_07/object_1.fs</td><td>jednoduchá třída s&nbsp;dvojicí atributů</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_1.fs</a></td></tr>
<tr><td>149</td><td>article_07/object_2.fs</td><td>přidání metody do třídy</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_2.fs</a></td></tr>
<tr><td>150</td><td>article_07/object_3.fs</td><td>třída s&nbsp;lokální vazbou na symbol (<i>binding</i>)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_3.fs</a></td></tr>
<tr><td>151</td><td>article_07/object_4.fs</td><td>dtto, ale s&nbsp;explicitním přístupem k&nbsp;atributům objektu</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_4.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_4.fs</a></td></tr>
<tr><td>152</td><td>article_07/object_5.fs</td><td>metoda vytvářející nový objekt</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_5.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_5.fs</a></td></tr>
<tr><td>153</td><td>article_07/object_6.fs</td><td>třída reprezentující dvouprvkový vektor</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_6.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_6.fs</a></td></tr>
<tr><td>154</td><td>article_07/object_7.fs</td><td>doplnění předchozí třídy o přetížený operátor +</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_7.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/object_7.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>155</td><td>article_07/oop_1.fs</td><td>objektově orientované programování: vztah mezi dvojicí tříd (předek, potomek)</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/oop_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/oop_1.fs</a></td></tr>
<tr><td>156</td><td>article_07/oop_2.fs</td><td>objektově orientované programování: dvojice tříd odvozená ze stejného předka</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/oop_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/oop_2.fs</a></td></tr>
<tr><td>157</td><td>article_07/oop_3.fs</td><td>objektově orientované programování: přetypování na předka</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/oop_3.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/oop_3.fs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>158</td><td>article_07/local_symbol_1.fs</td><td>čtení atributů objektu mimo definici třídy</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/local_symbol_1.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/local_symbol_1.fs</a></td></tr>
<tr><td>159</td><td>article_07/local_symbol_2.fs</td><td>čtení lokálních symbolů objektu mimo definici třídy</td><td><a href="https://github.com/tisnik/f-sharp-examples/tree/master/article_07/local_symbol_2.fs">https://github.com/tisnik/f-sharp-examples/tree/master/article_07/local_symbol_2.fs</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny knihy
o jazyku ML resp.&nbsp;Standard ML i knihy o programovacím jazyku OCaml, který
ze Standard ML ze značné míry vychází. A samozřejmě nezapomeneme ani na knihy o
jazyku F#:</div></p>

<ol>

<li>Get Programming with F#<br />
<a href="https://www.manning.com/books/get-programming-with-f-sharp">https://www.manning.com/books/get-programming-with-f-sharp</a>
</li>

<li>F# for Scientists<br />
<a href="https://www.amazon.com/F-Scientists-Jon-Harrop-ebook/dp/B005PS97RO">https://www.amazon.com/F-Scientists-Jon-Harrop-ebook/dp/B005PS97RO</a>
</li>

<li>Domain Modeling Made Functional<br />
<a href="https://fsharpforfunandprofit.com/books/">https://fsharpforfunandprofit.com/books/</a>
</li>

<li>Functional Programming with F# (na Overleaf, tedy i se zdrojovými kódy)<br />
<a href="https://www.overleaf.com/project/5bf2cb3cd9568d5a75bfcba9">https://www.overleaf.com/project/5bf2cb3cd9568d5a75bfcba9</a>
</li>

<li>Book of F#<br />
<a href="https://nostarch.com/fsharp">https://nostarch.com/fsharp</a>
</li>

<li>F# Programming (Wikibook)<br />
<a href="https://en.wikibooks.org/wiki/F_Sharp_Programming">https://en.wikibooks.org/wiki/F_Sharp_Programming</a>
</li>

<li>Stylish F#: Crafting Elegant Functional Code for .NET and .NET Core<br />
<a href="https://www.amazon.com/dp/1484239997/">https://www.amazon.com/dp/1484239997/</a>
</li>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>General-Purpose, Industrial-Strength, Expressive, and Safe<br />
<a href="https://ocaml.org/">https://ocaml.org/</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

<li>ForLoops<br />
<a href="http://mlton.org/ForLoops">http://mlton.org/ForLoops</a>
</li>

<li>Funkcionální dobrodružství v&nbsp;JavaScriptu<br />
<a href="https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html">https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html</a>
</li>

<li>Recenze knihy Functional Thinking (Paradigm over syntax)<br />
<a href="https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>.NET framework<br />
<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a>
</li>

<li>F# - .NET Blog<br />
<a href="https://devblogs.microsoft.com/dotnet/category/fsharp/">https://devblogs.microsoft.com/dotnet/category/fsharp/</a>
</li>

<li>Playground: OCaml<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>The F# Survival Guide<br />
<a href="https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx">https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Don Syme<br />
<a href="https://en.wikipedia.org/wiki/Don_Syme">https://en.wikipedia.org/wiki/Don_Syme</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Why Programmers Need Limits<br />
<a href="https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db">https://cscalfani.medium.com/why-programmers-need-limits-3d96e1a0a6db</a>
</li>

<li>Signatures<br />
<a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files">https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/signature-files</a>
</li>

<li>F# for Linux People<br />
<a href="https://carpenoctem.dev/blog/fsharp-for-linux-people/">https://carpenoctem.dev/blog/fsharp-for-linux-people/</a>
</li>

<li>Ionide project<br />
<a href="https://ionide.io/">https://ionide.io/</a>
</li>

<li>FsAutoComplete<br />
<a href="https://ionide.io/Tools/fsac.html">https://ionide.io/Tools/fsac.html</a>
</li>

<li>Interactive (.NET for Jupyter Notebook)<br />
<a href="https://github.com/dotnet/interactive/#jupyter-and-nteract">https://github.com/dotnet/interactive/#jupyter-and-nteract</a>
</li>

<li>let Bindings<br />
<a href="https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/let-bindings.md">https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/let-bindings.md</a>
</li>

<li>Lambda Expressions: The fun Keyword (F#)<br />
<a href="https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/lambda-expressions-the-fun-keyword.md">https://github.com/dotnet/docs/blob/main/docs/fsharp/language-reference/functions/lambda-expressions-the-fun-keyword.md</a>
</li>

<li>Infographic showing code complexity vs developer experience<br />
<a href="https://twitter.com/rossipedia/status/1580639227313676288">https://twitter.com/rossipedia/status/1580639227313676288</a>
</li>

<li>OCaml for the Masses: Why the next language you learn should be functional<br />
<a href="https://queue.acm.org/detail.cfm?id=2038036">https://queue.acm.org/detail.cfm?id=2038036</a>
</li>

<li>Try EIO<br />
<a href="https://patricoferris.github.io/try-eio/">https://patricoferris.github.io/try-eio/</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>ML &ndash; funkcionální jazyk s revolučním typovým systémem<br />
<a href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/</a>
</li>

<li>Funkce a typový systém programovacího jazyka ML<br />
<a href="https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/">https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/</a>
</li>

<li>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML<br />
<a href="https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/">https://www.root.cz/clanky/curryfikace-currying-vyjimky-a-vlastni-operatory-v-jazyku-ml/</a>
</li>

<li>Operátor J (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/J_operator">https://en.wikipedia.org/wiki/J_operator</a>
</li>

<li>Standard ML (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Standard_ML">https://en.wikipedia.org/wiki/Standard_ML</a>
</li>

<li>Xavier Leroy<br />
<a href="https://en.wikipedia.org/wiki/Xavier_Leroy">https://en.wikipedia.org/wiki/Xavier_Leroy</a>
</li>

<li>Unit type<br />
<a href="https://en.wikipedia.org/wiki/Unit_type">https://en.wikipedia.org/wiki/Unit_type</a>
</li>

<li>The Option type<br />
<a href="https://fsharpforfunandprofit.com/posts/the-option-type/">https://fsharpforfunandprofit.com/posts/the-option-type/</a>
</li>

<li>Operators<br />
<a href="https://ocaml.org/docs/operators">https://ocaml.org/docs/operators</a>
</li>

<li>Operator overloading<br />
<a href="https://en.wikipedia.org/wiki/Operator_overloading">https://en.wikipedia.org/wiki/Operator_overloading</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

